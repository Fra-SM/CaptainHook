/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */
    
    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));

    //the following 3 function hooks could in theory be removed since the respective functions
    //call NtDelayExecution under the hood, we keep them for the sake of results specificity
    const Beep = Module.getExportByName("Kernel32.dll", 'Beep');
    Interceptor.attach(Beep, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        //send("Beep frequency: " + args[0].toUInt32()); //DWORD dwFreq
        send("[Stalling] Beep - duration: " + args[1].toUInt32()); //DWORD dwDuration
        args[1] = ptr(0); //modified argument
      }
    });

    const Sleep = Module.getExportByName("Kernel32.dll", 'Sleep');
    Interceptor.attach(Sleep, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let duration = args[0].toUInt32();
        if (duration > 0)
          send("[Stalling] Sleep - duration: " + duration); //DWORD dwMilliseconds
        args[0] = ptr(0); //modified argument
      }
    });

    const SleepEx = Module.getExportByName("Kernel32.dll", 'SleepEx');
    Interceptor.attach(SleepEx, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let duration = args[0].toUInt32();
        if (duration > 0)
          send("[Stalling] SleepEx - duration: " + duration); //DWORD dwMilliseconds
        args[0] = ptr(0); //modified argument
      }
    });

    const WaitForSingleObject = Module.getExportByName("Kernel32.dll", 'WaitForSingleObject');
    Interceptor.attach(WaitForSingleObject, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let duration = args[1].toUInt32();
        if (duration > 0)
          send("[Stalling] WaitForSingleObject - duration: " + duration); //DWORD dwMilliseconds
        args[1] = ptr(0); //modified argument
      }
    });

    const WaitForSingleObjectEx = Module.getExportByName("Kernel32.dll", 'WaitForSingleObjectEx');
    Interceptor.attach(WaitForSingleObjectEx, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let duration = args[1].toUInt32();
        if (duration > 0)
          send("[Stalling] WaitForSingleObjectEx - duration: " + duration); //DWORD dwMilliseconds
        args[1] = ptr(0); //modified argument
      }
    });

    const WaitForMultipleObjects = Module.getExportByName("Kernel32.dll", 'WaitForMultipleObjects');
    Interceptor.attach(WaitForMultipleObjects, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let duration = args[3].toUInt32();
        if (duration > 0)
          send("[Stalling] WaitForMultipleObjects - duration: " + duration); //DWORD dwMilliseconds
        args[3] = ptr(0); //modified argument
      }
    });

    const WaitForMultipleObjectsEx = Module.getExportByName("Kernel32.dll", 'WaitForMultipleObjectsEx');
    Interceptor.attach(WaitForMultipleObjectsEx, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let duration = args[3].toUInt32();
        if (duration > 0)
          send("[Stalling] WaitForMultipleObjectsEx - duration: " + duration); //DWORD dwMilliseconds
        args[3] = ptr(0); //modified argument
      }
    });

    const NtDelayExecution = Module.getExportByName("ntdll.dll", 'NtDelayExecution');
    Interceptor.attach(NtDelayExecution, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Stalling] NtDelayExecution - delay: " + args[1].readLong()); //PLARGE_INTEGER DelayInterval
        args[1] = ptr(0); //modified argument
      }
    });

    const SetTimer = Module.getExportByName("User32.dll", 'SetTimer');
    Interceptor.attach(SetTimer, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let timeout = args[2].toUInt32();
        if (timeout > 0)
          send("[Stalling] SetTimer - timeout: " + timeout); //UINT uElapse
        args[2] = ptr(0); //modified argument
      }
    });

    const SetWaitableTimer = Module.getExportByName("Kernel32.dll", 'SetWaitableTimer');
    Interceptor.attach(SetWaitableTimer, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Stalling] SetWaitableTimer - timeout: " + args[1].readLong()); //const LARGE_INTEGER *lpDueTime
        args[1] = ptr(0); //modified argument
      }
    });

    const SetWaitableTimerEx = Module.getExportByName("Kernel32.dll", 'SetWaitableTimerEx');
    Interceptor.attach(SetWaitableTimerEx, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Stalling] SetWaitableTimerEx - timeout: " + args[1].readLong()); //const LARGE_INTEGER *lpDueTime
        args[1] = ptr(0); //modified argument
      }
    });

    const CreateTimerQueueTimer = Module.getExportByName("Kernel32.dll", 'CreateTimerQueueTimer');
    Interceptor.attach(CreateTimerQueueTimer, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let timeout = args[4].toUInt32();
        if (timeout > 0)
          send("[Stalling] CreateTimerQueueTimer - timeout: " + timeout); //DWORD DueTime
        args[4] = ptr(0); //modified argument
      }
    });

    const timeSetEvent = Module.getExportByName("Winmm.dll", 'timeSetEvent');
    Interceptor.attach(timeSetEvent, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let delay = args[0].toUInt32();
        if (delay > 0)
          send("[Stalling] timeSetEvent - delay: " + delay); //UINT uDelay
        args[0] = ptr(0); //modified argument
      }
    });

    /*in this case we replace the Timeout argument (index 7), but we could also
    set the IP address argument (index 1) to a reachable one such as 8.8.8.8 in case
    the function tries to determine if the program is running in an isolated environment*/
    const IcmpSendEcho = Module.getExportByName(null, 'IcmpSendEcho');
    Interceptor.attach(IcmpSendEcho, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Stalling] IcmpSendEcho - timeout: " + args[7].toUInt32()); //DWORD Timeout
        args[7] = ptr(0); //modified argument
      }
    });

    const IcmpSendEcho2 = Module.getExportByName(null, 'IcmpSendEcho2');
    Interceptor.attach(IcmpSendEcho2, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Stalling] IcmpSendEcho2 - timeout: " + args[10].toUInt32()); //DWORD Timeout
        args[10] = ptr(0); //modified argument
      }
    });

    const IcmpSendEcho2Ex = Module.getExportByName(null, 'IcmpSendEcho2Ex');
    Interceptor.attach(IcmpSendEcho2Ex, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Stalling] IcmpSendEcho2Ex - timeout: " + args[11].toUInt32()); //DWORD Timeout
        args[11] = ptr(0); //modified argument
      }
    });

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
}
