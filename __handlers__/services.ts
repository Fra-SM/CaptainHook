/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */
  
    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));
    const onlyAppCode = true;

    let services_blacklist = [
        "vmwarehostd",
        "vmware",
        "vmtools",
        "vmvss",
        "vgauthservice",
        "vboxservice",
        "vbox",
        "vboxsds",
        "vmnetdhcp",
        "vmusbarbservice",
        "vmauthdservice",
        "vboxguest",
        "vboxsf",
        "vmmemctl",
        "vmmouse",
        "vmxnet",
        "vmscsi",
        "vmhgfs",
        "vmrawdsk",
        "vmx_svga",
        "vmx86",
        "vmci",
        "vboxmouse",
        "vmic" //detects Hyper-V services
    ];

    const OpenSCManagerA = Module.getExportByName('Advapi32.dll', 'OpenSCManagerA');
    Interceptor.attach(OpenSCManagerA, {
      onEnter() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        console.log("[Services] OpenSCManagerA");
      }
    });

    const OpenSCManagerW = Module.getExportByName('Advapi32.dll', 'OpenSCManagerW');
    Interceptor.attach(OpenSCManagerW, {
      onEnter() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        console.log("[Services] OpenSCManagerW");
      }
    });

    //could have also simply changed the return value to NULL to make it look 
    //like the blacklisted service is not running, using onLeave(retval)
    const OpenServiceA = Module.getExportByName('Advapi32.dll', 'OpenServiceA');
    Interceptor.attach(OpenServiceA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_service = args[1].readAnsiString(); //LPCSTR lpServiceName
        let to_check = checked_service !== null ? checked_service.toLowerCase() : '0123456789';
        for (let s of services_blacklist) {
            if (to_check.includes(s))
            {
                send("[Services] OpenService - service checked: " + checked_service);
                //replace the service's name if blacklisted
                const dummyService = Memory.allocAnsiString('meow');
                this.dummyService = dummyService;
                args[1] = dummyService;
            }
        }
      }
    });

    const OpenServiceW = Module.getExportByName('Advapi32.dll', 'OpenServiceW');
    Interceptor.attach(OpenServiceW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_service = args[1].readUtf16String(); //LPCWSTR lpServiceName
        let to_check = checked_service !== null ? checked_service.toLowerCase() : '0123456789';
        for (let s of services_blacklist) {
            if (to_check.includes(s))
            {
                send("[Services] OpenService - service checked: " + checked_service);
                //replace the service's name if blacklisted
                const dummyService = Memory.allocUtf16String('meow');
                this.dummyService = dummyService;
                args[1] = dummyService;
            }      
        }
      }
    });

    const GetServiceKeyNameA = Module.getExportByName('Advapi32.dll', 'GetServiceKeyNameA');
    Interceptor.attach(GetServiceKeyNameA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_service = args[1].readAnsiString(); //LPCSTR lpDisplayName
        let to_check = checked_service !== null ? checked_service.toLowerCase() : '0123456789';
        for (let s of services_blacklist) {
            if (to_check.includes(s))
            {
                send("[Services] GetServiceKeyName - service checked: " + checked_service);
                //replace the service's name if blacklisted
                const dummyService = Memory.allocAnsiString('meow');
                this.dummyService = dummyService;
                args[1] = dummyService;
            }      
        }
      }
    });

    const GetServiceKeyNameW = Module.getExportByName('Advapi32.dll', 'GetServiceKeyNameW');
    Interceptor.attach(GetServiceKeyNameW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_service = args[1].readUtf16String(); //LPCWSTR lpDisplayName
        let to_check = checked_service !== null ? checked_service.toLowerCase() : '0123456789';
        for (let s of services_blacklist) {
            if (to_check.includes(s))
            {
                send("[Services] GetServiceKeyName - service checked: " + checked_service);
                //replace the service's name if blacklisted
                const dummyService = Memory.allocUtf16String('meow');
                this.dummyService = dummyService;
                args[1] = dummyService;
            }
        }
      }
    });

    const GetServiceDisplayNameA = Module.getExportByName('Advapi32.dll', 'GetServiceDisplayNameA');
    Interceptor.attach(GetServiceDisplayNameA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_service = args[1].readAnsiString(); //LPCSTR lpServiceName
        let to_check = checked_service !== null ? checked_service.toLowerCase() : '0123456789';
        for (let s of services_blacklist) {
            if (to_check.includes(s))
            {
                send("[Services] GetServiceDisplayName - service checked: " + checked_service);
                //replace the service's name if blacklisted
                const dummyService = Memory.allocAnsiString('meow');
                this.dummyService = dummyService;
                args[1] = dummyService;
            }      
        }
      }
    });

    const GetServiceDisplayNameW = Module.getExportByName('Advapi32.dll', 'GetServiceDisplayNameW');
    Interceptor.attach(GetServiceDisplayNameW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_service = args[1].readUtf16String(); //LPCWSTR lpServiceName
        let to_check = checked_service !== null ? checked_service.toLowerCase() : '0123456789';
        for (let s of services_blacklist) {
            if (to_check.includes(s))
            {
                send("[Services] GetServiceDisplayName - service checked: " + checked_service);
                //replace the service's name if blacklisted
                const dummyService = Memory.allocUtf16String('meow');
                this.dummyService = dummyService;
                args[1] = dummyService;
            }      
        }
      }
    });

    const EnumServicesStatusA = Module.getExportByName('Advapi32.dll', 'EnumServicesStatusA');
    Interceptor.attach(EnumServicesStatusA, {
      onEnter(args) {
        this.lpServices = args[3]; //nativepointer to ENUM_SERVICE_STATUS
        this.numServices = args[6]; //number of services (LPDWORD)
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Services] EnumServicesStatus");
        const numSrv = this.numServices.readUInt();
        if (numSrv > 0)
          for (var i = 0; i < numSrv; i++)
          {
            this.serviceName = this.lpServices.add(i * (28 + Process.pointerSize * 2)).readPointer().readAnsiString();
            //console.log(this.serviceName);
            this.displayName = this.lpServices.add(i * (28 + Process.pointerSize * 2) + Process.pointerSize).readPointer().readAnsiString();
            //console.log(this.displayName);
            for (let s of services_blacklist) {
                if (this.serviceName.toLowerCase().includes(s))
                {
                    send("[Services] EnumServicesStatus - replaced service name: " + this.serviceName);
                    console.log('Replacing service name:', this.serviceName);
                    //replace the service's name if blacklisted
                    this.lpServices.add(i * (28 + Process.pointerSize * 2)).readPointer().writeAnsiString('meow');
                    //console.log(this.lpServices.add(i * (28 + Process.pointerSize * 2)).readPointer().readAnsiString());
                }   
                if (this.displayName.toLowerCase().includes(s)) 
                {
                  send("[Services] EnumServicesStatus - replaced service display name: " + this.displayName);
                  //replace the service's name if blacklisted
                  this.lpServices.add(i * (28 + Process.pointerSize * 2) + Process.pointerSize).readPointer().writeAnsiString('meow');
                  //console.log(this.lpServices.add((i * (28 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().readAnsiString());
                }   
            }
          }
      }
    });

    const EnumServicesStatusW = Module.getExportByName('Advapi32.dll', 'EnumServicesStatusW');
    Interceptor.attach(EnumServicesStatusW, {
      onEnter(args) {
        this.lpServices = args[3]; //nativepointer to ENUM_SERVICE_STATUS
        this.numServices = args[6]; //number of services (LPDWORD)
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Services] EnumServicesStatus");
        const numSrv = this.numServices.readUInt();
        if (numSrv > 0)
          for (var i = 0; i < numSrv; i++)
          {
            this.serviceName = this.lpServices.add(i * (28 + Process.pointerSize * 2)).readPointer().readUtf16String();
            //console.log(this.serviceName);
            this.displayName = this.lpServices.add((i * (28 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().readUtf16String();
            //console.log(this.displayName);
            for (let s of services_blacklist) {
                if (this.serviceName.toLowerCase().includes(s))
                {
                  send("[Services] EnumServicesStatus - replaced service name: " + this.serviceName);
                  //replace the service's name if blacklisted
                  this.lpServices.add(i * (28 + Process.pointerSize * 2)).readPointer().writeUtf16String('meow');
                  //console.log(this.lpServices.add(i * (28 + Process.pointerSize * 2)).readPointer().readUtf16String());
                }   
                if (this.displayName.toLowerCase().includes(s)) 
                {
                  send("[Services] EnumServicesStatus - replaced service display name: " + this.displayName);
                  //replace the service's name if blacklisted
                  this.lpServices.add((i * (28 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().writeUtf16String('meow');
                  //console.log(this.lpServices.add((i * (28 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().readUtf16String());
                }   
            }
          }
      }
    });

    //the following 2 hooks may not work in the future if more infoLevel parameters are added to these APIs
    const EnumServicesStatusExA = Module.getExportByName('Advapi32.dll', 'EnumServicesStatusExA');
    Interceptor.attach(EnumServicesStatusExA, {
      onEnter(args) {
        this.lpServices = args[4]; //nativepointer to ENUM_SERVICE_STATUS_PROCESS
        this.numServices = args[7]; //number of services (LPDWORD)
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Services] EnumServicesStatus");
        const numSrv = this.numServices.readUInt();
        if (numSrv > 0)
          for (var i = 0; i < numSrv; i++)
          {
            this.serviceName = this.lpServices.add(i * (36 + Process.pointerSize * 2)).readPointer().readAnsiString();
            //console.log(this.serviceName);
            this.displayName = this.lpServices.add((i * (36 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().readAnsiString();
            //console.log(this.displayName);
            for (let s of services_blacklist) {
                if (this.serviceName.toLowerCase().includes(s))
                {
                  send("[Services] EnumServicesStatus - replaced service name: " + this.serviceName);
                    //replace the service's name if blacklisted
                    this.lpServices.add(i * (36 + Process.pointerSize * 2)).readPointer().writeAnsiString('meow');
                    //console.log(this.lpServices.add(i * (28 + Process.pointerSize * 2)).readPointer().readAnsiString());
                }   
                if (this.displayName.toLowerCase().includes(s)) 
                {
                  send("[Services] EnumServicesStatus - replaced service display name: " + this.displayName);
                  //replace the service's name if blacklisted
                  this.lpServices.add((i * (36 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().writeAnsiString('meow');
                  //console.log(this.lpServices.add((i * (28 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().readAnsiString());
                }   
            }
          }
      }
    });

    const EnumServicesStatusExW = Module.getExportByName('Advapi32.dll', 'EnumServicesStatusExW');
    Interceptor.attach(EnumServicesStatusExW, {
      onEnter(args) {
        this.lpServices = args[4]; //nativepointer to ENUM_SERVICE_STATUS_PROCESS
        this.numServices = args[7]; //number of services (LPDWORD)
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Services] EnumServicesStatus");
        const numSrv = this.numServices.readUInt();
        if (numSrv > 0)
          for (var i = 0; i < numSrv; i++)
          {
            this.serviceName = this.lpServices.add(i * (36 + Process.pointerSize * 2)).readPointer().readUtf16String();
            //console.log(this.serviceName);
            this.displayName = this.lpServices.add((i * (36 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().readUtf16String();
            //console.log(this.displayName);
            for (let s of services_blacklist) {
                if (this.serviceName.toLowerCase().includes(s))
                {
                  send("[Services] EnumServicesStatus - replaced service name: " + this.serviceName);
                    //replace the service's name if blacklisted
                    this.lpServices.add(i * (36 + Process.pointerSize * 2)).readPointer().writeUtf16String('meow');
                    //console.log(this.lpServices.add(i * (28 + Process.pointerSize * 2)).readPointer().readUtf16String());
                }   
                if (this.displayName.toLowerCase().includes(s)) 
                {
                  send("[Services] EnumServicesStatus - replaced service display name: " + this.displayName);
                  //replace the service's name if blacklisted
                  this.lpServices.add((i * (36 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().writeUtf16String('meow');
                  //console.log(this.lpServices.add((i * (28 + Process.pointerSize * 2)) + Process.pointerSize).readPointer().readUtf16String());
                }   
            }
          }
      }
    });

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
  