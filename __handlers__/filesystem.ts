/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */

    let filesystem_blacklist = [
        "malware",
        "sandbox",
        "virus",
        "sample.exe",
        "vmware",
        "vbox",
        "virtualbox",
        "vmsrvc.sys",
        "vpc-s3.sys",
        "vmmouse.sys",
        "vmnet.sys",
        "vmxnet.sys",
        "vmhgfs.sys",
        "vmx86.sys",
        "hgfs.sys",
        "prleth.sys",
        "prlfs.sys",
        "prlmouse.sys",
        "prlvideo.sys",
        "prltime.sys",
        "prl_pv32.sys",
        "prl_paravirt_32.sys"
    ];

    let products_blacklist = [
        "wireshark",
        "ida",
        "ghidra",
        "ollydbg",
        "windbg",
        "peid",
        "pestudio",
        "pesieve",
        "regshot",
        "hashcat",
        "die",
        "dnspyex",
        "exiftool",
        "floss",
        "hxd",
        "metasploit",
        "apktool",
        "cyberchef",
        "cygwin",
        "cutter",
        "cff explorer",
        "malcat",
        "mimikatz",
        "yara"
    ];

    const all_blacklist = [...filesystem_blacklist, ...products_blacklist];

    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));

    const GetModuleFileNameA = Module.getExportByName("Kernel32.dll", 'GetModuleFileNameA');
    Interceptor.attach(GetModuleFileNameA, {
      onEnter(args) {
        this.lpFilename = args[1]; //LPSTR lpFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (retval.toUInt32() !== 0)
        for (let f of filesystem_blacklist)
            if (this.lpFilename.readAnsiString().toLowerCase().includes(f))
            {
                //retval.replace(ptr(0)); //fake function failure
                this.lpFilename.writeAnsiString('D:\\meow');
                send("[Filesystem] GetModuleFileNameA - replaced file path: " + this.lpFilename.readAnsiString());
            }       
      }
    });

    const GetModuleFileNameW = Module.getExportByName("Kernel32.dll", 'GetModuleFileNameW');
    Interceptor.attach(GetModuleFileNameW, {
      onEnter(args) {
        this.lpFilename = args[1]; //LPWSTR lpFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (retval.toUInt32() !== 0)
            for (let f of filesystem_blacklist)
                if (this.lpFilename.readUtf16String().toLowerCase().includes(f))
                {
                    this.lpFilename.writeUtf16String('D:\\meow');
                    send("[Filesystem] GetModuleFileNameW - replaced file path: " + this.lpFilename.readUtf16String());
                }       
      }
    });
    
    const QueryFullProcessImageNameA = Module.getExportByName("Kernel32.dll", 'QueryFullProcessImageNameA');
    Interceptor.attach(QueryFullProcessImageNameA, {
      onEnter(args) {
        this.lpFilename = args[2]; //LPSTR lpFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (retval.toInt32() !== 0)
            for (let f of filesystem_blacklist)
                if (this.lpFilename.readAnsiString().toLowerCase().includes(f))
                {
                    this.lpFilename.writeAnsiString('D:\\meow');
                    send("[Filesystem] QueryFullProcessImageNameA - replaced file path: " + this.lpFilename.readAnsiString());
                }       
      }
    });

    const QueryFullProcessImageNameW = Module.getExportByName("Kernel32.dll", 'QueryFullProcessImageNameW');
    Interceptor.attach(QueryFullProcessImageNameW, {
      onEnter(args) {
        this.lpFilename = args[2]; //LPWSTR lpFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (retval.toInt32() !== 0)
            for (let f of filesystem_blacklist)
                if (this.lpFilename.readUtf16String().toLowerCase().includes(f))
                {
                    this.lpFilename.writeUtf16String('D:\\meow');
                    send("[Filesystem] QueryFullProcessImageNameW - replaced file path: " + this.lpFilename.readUtf16String());
                }       
      }
    });

    const GetProcessImageFileNameA = Module.getExportByName(null, 'GetProcessImageFileNameA');
    Interceptor.attach(GetProcessImageFileNameA, {
      onEnter(args) {
        this.lpFilename = args[1]; //LPSTR lpImageFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (retval.toUInt32() !== 0)
            for (let f of filesystem_blacklist)
                if (this.lpFilename.readAnsiString().toLowerCase().includes(f))
                {
                    this.lpFilename.writeAnsiString('D:\\meow');
                    send("[Filesystem] GetProcessImageFileNameA - replaced file path: " + this.lpFilename.readAnsiString());
                }       
      }
    });

    const GetProcessImageFileNameW = Module.getExportByName(null, 'GetProcessImageFileNameW');
    Interceptor.attach(GetProcessImageFileNameW, {
      onEnter(args) {
        this.lpFilename = args[1]; //LPWSTR lpImageFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (retval.toUInt32() !== 0)
            for (let f of filesystem_blacklist)
                if (this.lpFilename.readUtf16String().toLowerCase().includes(f))
                {
                    this.lpFilename.writeUtf16String('D:\\meow');
                    send("[Filesystem] GetProcessImageFileNameW - replaced file path: " + this.lpFilename.readUtf16String());
                }       
      }
    });
    
    const NtOpenFile = Module.getExportByName('ntdll.dll', 'NtOpenFile');
    Interceptor.attach(NtOpenFile, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.fileName = args[2].add(8).readPointer().add(4).readPointer(); //ObjectAttributes->ObjectName->Buffer
        //console.log(this.fileName.readUtf16String());
        for (let f of filesystem_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] NtOpenFile - file checked: ${this.fileName.readUtf16String()}`);
                this.fileName.writeUtf16String('meow');
                console.log(this.fileName.readUtf16String());
            }   
        }
      },
    });

    const NtCreateFile = Module.getExportByName('ntdll.dll', 'NtCreateFile');
    Interceptor.attach(NtCreateFile, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.fileName = args[2].add(8).readPointer().add(4).readPointer(); //ObjectAttributes->ObjectName->Buffer
        //console.log(this.fileName.readUtf16String());
        for (let f of filesystem_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] NtCreateFile - file checked: ${this.fileName.readUtf16String()}`);
                this.fileName.writeUtf16String('meow');
                console.log(this.fileName.readUtf16String());
            }   
        }
      },
    });

    const NtQueryAttributesFile = Module.getExportByName('ntdll.dll', 'NtQueryAttributesFile');
    Interceptor.attach(NtQueryAttributesFile, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.fileName = args[0].add(8).readPointer().add(4).readPointer(); //ObjectAttributes->ObjectName->Buffer
        //console.log(this.fileName.readUtf16String());
        for (let f of filesystem_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] NtQueryAttributesFile - file checked: ${this.fileName.readUtf16String()}`);
                this.fileName.writeUtf16String('meow');
                console.log(this.fileName.readUtf16String());
            }   
        }
      },
    });

    const NtQueryDirectoryFileEx = Module.getExportByName('ntdll.dll', 'NtQueryDirectoryFileEx');
    Interceptor.attach(NtQueryDirectoryFileEx, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.fileInfoClass = args[7]; //FILE_INFORMATION_CLASS FileInformationClass
        this.fileInfo = args[5]; //PVOID FileInformation
        this.offset = 0; //offset to the filename field

        if (this.fileInfoClass.toInt32() === 1) //1 FileDirectoryInformation
            this.offset = 64; //WCHAR FileName
        if (this.fileInfoClass.toInt32() === 2) //2 FileFullDirectoryInformation
            this.offset = 68; //WCHAR FileName
        if (this.fileInfoClass.toInt32() === 3) //3 FileBothDirectoryInformation
            this.offset = 73; //WCHAR ShortName[12]
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        let NextEntryOffset = this.fileInfo.readU32();
        //while there are still files in the list (this should be fixed because it skips the first file)
        while (NextEntryOffset != 0) //ULONG NextEntryOffset
        {
            //console.log(NextEntryOffset);
            let fileName = this.fileInfo.add(NextEntryOffset).add(this.offset).readPointer().readUtf16String();
            console.log(fileName);
            for (let f of all_blacklist)
            {
                if (fileName.toLowerCase().includes(f))
                {
                    send(`[Filesystem] NtQueryDirectoryFileEx - file checked: ${fileName}`);
                    this.sysInfo.add(NextEntryOffset).add(this.offset).readPointer().writeUtf16String('meow');
                }
            }
                
            let newOffset = this.fileInfo.add(NextEntryOffset).readU32();
            if (newOffset != 0)
                NextEntryOffset = NextEntryOffset + newOffset;
            else
                NextEntryOffset = 0;
        }
      }
    });

    const FindFirstFileA = Module.getExportByName('Kernel32.dll', 'FindFirstFileA');
    Interceptor.attach(FindFirstFileA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let fileName = args[0].readAnsiString(); //LPCSTR lpFileName
        let to_check = fileName !== null ? fileName.toLowerCase() : '0123456789';
        for (let f of all_blacklist) {
            if (to_check.includes(f))
            {
                send("[Filesystem] FindFirstFileA - replaced file: " + fileName);
                //replace the file's name if blacklisted
                const dummyFile = Memory.allocAnsiString('meow');
                this.dummyFile = dummyFile;
                args[0] = dummyFile;
            }
        }
      }
    });

    const FindFirstFileW = Module.getExportByName('Kernel32.dll', 'FindFirstFileW');
    Interceptor.attach(FindFirstFileW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let fileName = args[0].readUtf16String(); //LPCWSTR lpFileName
        let to_check = fileName !== null ? fileName.toLowerCase() : '0123456789';
        for (let f of all_blacklist) {
            if (to_check.includes(f))
            {
                send("[Filesystem] FindFirstFileW - replaced file: " + fileName);
                //replace the file's name if blacklisted
                const dummyFile = Memory.allocUtf16String('meow');
                this.dummyFile = dummyFile;
                args[0] = dummyFile;
            }
        }
      }
    });

    const FindFirstFileExA = Module.getExportByName('Kernel32.dll', 'FindFirstFileExA');
    Interceptor.attach(FindFirstFileExA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let fileName = args[0].readAnsiString(); //LPCSTR lpFileName
        let to_check = fileName !== null ? fileName.toLowerCase() : '0123456789';
        for (let f of all_blacklist) {
            if (to_check.includes(f))
            {
                send("[Filesystem] FindFirstFileExA - replaced file: " + fileName);
                //replace the file's name if blacklisted
                const dummyFile = Memory.allocAnsiString('meow');
                this.dummyFile = dummyFile;
                args[0] = dummyFile;
            }
        }
      }
    });

    const FindFirstFileExW = Module.getExportByName('Kernel32.dll', 'FindFirstFileExW');
    Interceptor.attach(FindFirstFileExW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let fileName = args[0].readUtf16String(); //LPCWSTR lpFileName
        let to_check = fileName !== null ? fileName.toLowerCase() : '0123456789';
        for (let f of all_blacklist) {
            if (to_check.includes(f))
            {
                send("[Filesystem] FindFirstFileExW - replaced file: " + fileName);
                //replace the file's name if blacklisted
                const dummyFile = Memory.allocUtf16String('meow');
                this.dummyFile = dummyFile;
                args[0] = dummyFile;
            }
        }
      }
    });

    const FindNextFileA = Module.getExportByName('Kernel32.dll', 'FindNextFileA');
    Interceptor.attach(FindNextFileA, {
      onEnter(args) {
        this.outStruct = args[1]; //LPWIN32_FIND_DATAA lpFindFileData
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (retval.toInt32() !== 0)
        {
            let fileName = this.outStruct.add(44).readCString(); //CHAR cFileName[MAX_PATH];
            for (let f of all_blacklist) {
                if (fileName.toLowerCase().includes(f))
                {
                    send("[Filesystem] FindNextFileA - replaced file: " + fileName);
                    //replace the file's name if blacklisted
                    this.outStruct.readPointer().add(44).writeUtf8String('meow');
                    console.log(this.outStruct.readPointer().add(44).readCString())
                }
            }
        }
      }
    });

    const FindNextFileW = Module.getExportByName('Kernel32.dll', 'FindNextFileW');
    Interceptor.attach(FindNextFileW, {
      onEnter(args) {
        this.outStruct = args[1]; //LPWIN32_FIND_DATAW lpFindFileData
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (retval.toInt32() !== 0)
        {
            let fileName = this.outStruct.add(44).readUtf16String(); //WCHAR cFileName[MAX_PATH];
            for (let f of all_blacklist) {
                if (fileName.toLowerCase().includes(f))
                {
                    send("[Filesystem] FindNextFileW - replaced file: " + fileName);
                    //replace the file's name if blacklisted
                    this.outStruct.readPointer().add(44).writeUtf16String('meow');
                    console.log(this.outStruct.readPointer().add(44).readUtf16String())
                }
            }
        }
      }
    });

    try {
        const MsiGetProductInfoA = Module.getExportByName('Msi.dll', 'MsiGetProductInfoA');
        Interceptor.attach(MsiGetProductInfoA, {
        onEnter(args) {
            this.property = args[1].readAnsiString(); //LPCSTR szAttribute
            this.productName = args[2]; //LPSTR lpValueBuf
            console.log(this.property);
        },

        onLeave() {
            if (!appModules.has(this.returnAddress))
                return;
            if (this.property === "INSTALLPROPERTY_INSTALLEDPRODUCTNAME")
            {
                for (let p of products_blacklist)
                {
                    if (this.productName.readAnsiString().toLowerCase().includes(p))
                    {
                        send(`[Filesystem] MsiGetProductInfoA - replaced product: ${this.productName.readAnsiString()}`);
                        this.productName.writeAnsiString('meow');
                        console.log(this.productName.readAnsiString());
                    }   
                }
            }
        }
        });

        const MsiGetProductInfoW = Module.getExportByName('Msi.dll', 'MsiGetProductInfoW');
        Interceptor.attach(MsiGetProductInfoW, {
        onEnter(args) {
            this.property = args[1].readUtf16String(); //LPCWSTR szAttribute
            this.productName = args[2]; //LPWSTR lpValueBuf
            console.log(this.property);
        },

        onLeave() {
            if (!appModules.has(this.returnAddress))
                return;
            if (this.property === "INSTALLPROPERTY_INSTALLEDPRODUCTNAME")
            {
                for (let p of products_blacklist)
                {
                    if (this.productName.readUtf16String().toLowerCase().includes(p))
                    {
                        send(`[Filesystem] MsiGetProductInfoW - replaced product: ${this.productName.readUtf16String()}`);
                        this.productName.writeUtf16String('meow');
                        console.log(this.productName.readUtf16String());
                    }   
                }
            }
        }
        });

        const MsiGetProductInfoExA = Module.getExportByName('Msi.dll', 'MsiGetProductInfoExA');
        Interceptor.attach(MsiGetProductInfoExA, {
        onEnter(args) {
            this.property = args[3].readAnsiString(); //LPCSTR szAttribute
            this.productName = args[4]; //LPSTR lpValueBuf
            console.log(this.property);
        },

        onLeave() {
            if (!appModules.has(this.returnAddress))
                return;
            if (this.property === "INSTALLPROPERTY_INSTALLEDPRODUCTNAME")
            {
                for (let p of products_blacklist)
                {
                    if (this.productName.readAnsiString().toLowerCase().includes(p))
                    {
                        send(`[Filesystem] MsiGetProductInfoExA - replaced product: ${this.productName.readAnsiString()}`);
                        this.productName.writeAnsiString('meow');
                        console.log(this.productName.readAnsiString());
                    }   
                }
            }
        }
        });

        const MsiGetProductInfoExW = Module.getExportByName('Msi.dll', 'MsiGetProductInfoExW');
        Interceptor.attach(MsiGetProductInfoExW, {
        onEnter(args) {
            this.property = args[3].readUtf16String(); //LPCWSTR szAttribute
            this.productName = args[4]; //LPWSTR lpValueBuf
            console.log(this.property);
        },

        onLeave() {
            if (!appModules.has(this.returnAddress))
                return;
            if (this.property === "INSTALLPROPERTY_INSTALLEDPRODUCTNAME")
            {
                for (let p of products_blacklist)
                {
                    if (this.productName.readUtf16String().toLowerCase().includes(p))
                    {
                        send(`[Filesystem] MsiGetProductInfoExW - replaced product: ${this.productName.readUtf16String()}`);
                        this.productName.writeUtf16String('meow');
                        console.log(this.productName.readUtf16String());
                    }   
                }
            }
        }
        });
    } catch (error) {
        console.log(error);
    }

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
