/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */

    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));
    const onlyAppCode = true;

    let original_filename = Process.enumerateModules()[0].name;

    let filesystem_blacklist = [
        "malware",
        "sandbox",
        "virus",
        "sample.exe",
        "vmware",
        "vbox",
        "virtualbox",
        "vmsrvc.sys",
        "vpc-s3.sys",
        "vmmouse.sys",
        "vmnet.sys",
        "vmxnet.sys",
        "vmhgfs.sys",
        "vmx86.sys",
        "hgfs.sys",
        "hyper",
        "prleth.sys",
        "prlfs.sys",
        "prlmouse.sys",
        "prlvideo.sys",
        "prltime.sys",
        "prl_pv32.sys",
        "prl_paravirt_32.sys",
        "sbiedll",
        "ntice",
        "sice",
        "ntfire",
        "debug",
        original_filename
    ];

    let products_blacklist = [
        "ollydbg",					 // OllyDebug debugger
        "processhacker",			 // Process Hacker
        "tcpview",					 // Part of Sysinternals Suite
        "autoruns",					 // Part of Sysinternals Suite
        "filemon",					 // Part of Sysinternals Suite
        "procmon",					 // Part of Sysinternals Suite
        "regmon",					 // Part of Sysinternals Suite
        "procexp",					 // Part of Sysinternals Suite
        "ida",						 // IDA Pro Interactive Disassembler
        "immunitydebugger",			 // ImmunityDebugger
        "wireshark",				 // Wireshark packet sniffer
        "dumpcap",					 // Network traffic dump tool
        "hookexplorer",				 // Find various types of runtime hooks
        "importrec",				 // Import Reconstructor
        "petools",					 // PE Tool
        "lordpe",					 // LordPE
        "sysinspector",				 // ESET SysInspector
        "proc_analyzer",			 // Part of SysAnalyzer iDefense
        "sysanalyzer",				 // Part of SysAnalyzer iDefense
        "sniff_hit",				 // Part of SysAnalyzer iDefense
        "windbg",					 // Microsoft WinDbg
        "joebox",                    // Joe Sandbox
        "resourcehacker",			 // Resource Hacker
        "x32dbg",					 // x32dbg
        "x64dbg",					 // x64dbg
        "fiddler",					 // Fiddler
        "httpdebugger",				 // Http Debugger
        "netmon",					 // Part of Sysinternals Suite
        "ghidra",
        "tcpdump",
        "netstat",					 
        "cain",						 
        "httpanalyzerstdv7",
        "apimonitor",
        "scylla",	
        "cheatengine",
        "frida",
        "peid",
        "pestudio",
        "pesieve",
        "regshot",
        "hashcat",
        "die",
        "dnspyex",
        "exiftool",
        "floss",
        "hxd",
        "metasploit",
        "apktool",
        "cyberchef",
        "cygwin",
        "cutter",
        "cff explorer",
        "malcat",
        "mimikatz",
        "yara",
        "titanhide"
        ];

    const all_blacklist = [...filesystem_blacklist, ...products_blacklist];

    const GetModuleFileNameA = Module.getExportByName("Kernel32.dll", 'GetModuleFileNameA');
    Interceptor.attach(GetModuleFileNameA, {
      onEnter(args) {
        this.lpFilename = args[1]; //LPSTR lpFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toUInt32() !== 0)
        for (let f of all_blacklist)
            if (this.lpFilename.readAnsiString().toLowerCase().includes(f))
            {
                //retval.replace(ptr(0)); //fake function failure
                send("[Filesystem] GetModuleFileName - replaced file path: " + this.lpFilename.readAnsiString());
                if (!this.lpFilename.readAnsiString().toLowerCase().includes(original_filename))
                    this.lpFilename.writeAnsiString('D:\\meow');
            }       
      }
    });

    const GetModuleFileNameW = Module.getExportByName("Kernel32.dll", 'GetModuleFileNameW');
    Interceptor.attach(GetModuleFileNameW, {
      onEnter(args) {
        this.lpFilename = args[1]; //LPWSTR lpFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toUInt32() !== 0)
            for (let f of all_blacklist)
                if (this.lpFilename.readUtf16String().toLowerCase().includes(f))
                {
                    send("[Filesystem] GetModuleFileName - replaced file path: " + this.lpFilename.readUtf16String());
                    if (!this.lpFilename.readUtf16String().toLowerCase().includes(original_filename))
                        this.lpFilename.writeUtf16String('D:\\meow');
                }       
      }
    });
    
    const QueryFullProcessImageNameA = Module.getExportByName("Kernel32.dll", 'QueryFullProcessImageNameA');
    Interceptor.attach(QueryFullProcessImageNameA, {
      onEnter(args) {
        this.lpFilename = args[2]; //LPSTR lpFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toInt32() !== 0)
            for (let f of all_blacklist)
                if (this.lpFilename.readAnsiString().toLowerCase().includes(f))
                {
                    send("[Filesystem] QueryFullProcessImageName - replaced file path: " + this.lpFilename.readAnsiString());
                    if (!this.lpFilename.readAnsiString().toLowerCase().includes(original_filename))
                        this.lpFilename.writeAnsiString('D:\\meow');
                }       
      }
    });

    const QueryFullProcessImageNameW = Module.getExportByName("Kernel32.dll", 'QueryFullProcessImageNameW');
    Interceptor.attach(QueryFullProcessImageNameW, {
      onEnter(args) {
        this.lpFilename = args[2]; //LPWSTR lpFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toInt32() !== 0)
            for (let f of all_blacklist)
                if (this.lpFilename.readUtf16String().toLowerCase().includes(f))
                {
                    send("[Filesystem] QueryFullProcessImageName - replaced file path: " + this.lpFilename.readUtf16String());
                    if (!this.lpFilename.readUtf16String().toLowerCase().includes(original_filename))
                        this.lpFilename.writeUtf16String('D:\\meow');
                }       
      }
    });

    const GetProcessImageFileNameA = Module.getExportByName(null, 'GetProcessImageFileNameA');
    Interceptor.attach(GetProcessImageFileNameA, {
      onEnter(args) {
        this.lpFilename = args[1]; //LPSTR lpImageFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toUInt32() !== 0)
            for (let f of all_blacklist)
                if (this.lpFilename.readAnsiString().toLowerCase().includes(f))
                {
                    send("[Filesystem] GetProcessImageFileName - replaced file path: " + this.lpFilename.readAnsiString());
                    if (!this.lpFilename.readAnsiString().toLowerCase().includes(original_filename))
                        this.lpFilename.writeAnsiString('D:\\meow');
                }       
      }
    });

    const GetProcessImageFileNameW = Module.getExportByName(null, 'GetProcessImageFileNameW');
    Interceptor.attach(GetProcessImageFileNameW, {
      onEnter(args) {
        this.lpFilename = args[1]; //LPWSTR lpImageFilename
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toUInt32() !== 0)
            for (let f of all_blacklist)
                if (this.lpFilename.readUtf16String().toLowerCase().includes(f))
                {
                    send("[Filesystem] GetProcessImageFileName - replaced file path: " + this.lpFilename.readUtf16String());
                    if (!this.lpFilename.readUtf16String().toLowerCase().includes(original_filename))
                        this.lpFilename.writeUtf16String('D:\\meow');
                    
                }       
      }
    });
    
    const OpenFile = Module.getExportByName('Kernel32.dll', 'OpenFile');
    Interceptor.attach(OpenFile, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[0]; //LPCSTR lpFileName
        console.log(this.fileName.readAnsiString());
        for (let f of all_blacklist)
        {
            if (this.fileName.readAnsitring().toLowerCase().includes(f))
            {
                send(`[Filesystem] OpenFile - file checked: ${this.fileName.readAnsiString()}`);
                if (!this.fileName.readAnsiString().toLowerCase().includes(original_filename))
                    this.fileName.writeAnsiString('meow');
                //console.log(this.fileName.readAnsiString());
            }   
        }
      },
    });

    const CreateFileA = Module.getExportByName('Kernel32.dll', 'CreateFileA');
    Interceptor.attach(CreateFileA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[0]; //LPCSTR lpFileName
        console.log(this.fileName.readAnsiString());
        for (let f of all_blacklist)
        {
            if (this.fileName.readAnsiString().toLowerCase().includes(f))
            {
                send(`[Filesystem] CreateFile - file checked: ${this.fileName.readAnsiString()}`);
                if (!this.fileName.readAnsiString().toLowerCase().includes(original_filename))
                    this.fileName.writeAnsiString('\\\.\\meow');
                //console.log(this.fileName.readAnsiString());
            }   
        }
      },
    });

    const CreateFileW = Module.getExportByName('Kernel32.dll', 'CreateFileW');
    Interceptor.attach(CreateFileW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[0]; //LPCWSTR lpFileName
        console.log(this.fileName.readUtf16String());
        for (let f of all_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] CreateFile - file checked: ${this.fileName.readUtf16String()}`);
                if (!this.fileName.readUtf16String().toLowerCase().includes(original_filename))
                    this.fileName.writeUtf16String('\\\.\\meow');
                //console.log(this.fileName.readUtf16String());
            }   
        }
      },
    });

    const CreateFile2 = Module.getExportByName('Kernel32.dll', 'CreateFile2');
    Interceptor.attach(CreateFile2, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[0]; //LPCWSTR lpFileName
        console.log(this.fileName.readUtf16String());
        for (let f of all_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] CreateFile - file checked: ${this.fileName.readUtf16String()}`);
                if (!this.fileName.readUtf16String().toLowerCase().includes(original_filename))
                    this.fileName.writeUtf16String('meow');
                //console.log(this.fileName.readUtf16String());
            }   
        }
      },
    });

    const GetFileAttributesA = Module.getExportByName('Kernel32.dll', 'GetFileAttributesA');
    Interceptor.attach(GetFileAttributesA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[0]; //LPCSTR lpFileName
        console.log(this.fileName.readAnsiString());
        for (let f of all_blacklist)
        {
            if (this.fileName.readAnsiString().toLowerCase().includes(f))
            {
                send(`[Filesystem] GetFileAttributes - file checked: ${this.fileName.readAnsiString()}`);
                if (!this.fileName.readAnsiString().toLowerCase().includes(original_filename))
                    this.fileName.writeAnsiString('meow');
                //console.log(this.fileName.readAnsiString());
            }   
        }
      },
    });

    const GetFileAttributesW = Module.getExportByName('Kernel32.dll', 'GetFileAttributesW');
    Interceptor.attach(GetFileAttributesW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[0]; //LPCWSTR lpFileName
        console.log(this.fileName.readUtf16String());
        for (let f of all_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] GetFileAttributes - file checked: ${this.fileName.readUtf16String()}`);
                if (!this.fileName.readUtf16String().toLowerCase().includes(original_filename))
                    this.fileName.writeUtf16String('meow');
                //console.log(this.fileName.readUtf16String());
            }   
        }
      },
    });

    const GetFileAttributesExA = Module.getExportByName('Kernel32.dll', 'GetFileAttributesExA');
    Interceptor.attach(GetFileAttributesExA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[0]; //LPCSTR lpFileName
        console.log(this.fileName.readAnsiString());
        for (let f of all_blacklist)
        {
            if (this.fileName.readAnsiString().toLowerCase().includes(f))
            {
                send(`[Filesystem] GetFileAttributes - file checked: ${this.fileName.readAnsiString()}`);
                if (!this.fileName.readAnsiString().toLowerCase().includes(original_filename))
                    this.fileName.writeAnsiString('meow');
                //console.log(this.fileName.readAnsiString());
            }   
        }
      },
    });

    const GetFileAttributesExW = Module.getExportByName('Kernel32.dll', 'GetFileAttributesExW');
    Interceptor.attach(GetFileAttributesExW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[0]; //LPCWSTR lpFileName
        console.log(this.fileName.readUtf16String());
        for (let f of all_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] GetFileAttributes - file checked: ${this.fileName.readUtf16String()}`);
                if (!this.fileName.readUtf16String().toLowerCase().includes(original_filename))
                    this.fileName.writeUtf16String('meow');
                //console.log(this.fileName.readUtf16String());
            }   
        }
      },
    });

    const NtOpenFile = Module.getExportByName('ntdll.dll', 'NtOpenFile');
    Interceptor.attach(NtOpenFile, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[2].add(8).readPointer().add(4).readPointer(); //ObjectAttributes->ObjectName->Buffer
        console.log(this.fileName.readUtf16String());
        for (let f of all_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] NtOpenFile - file checked: ${this.fileName.readUtf16String()}`);
                if (!this.fileName.readUtf16String().toLowerCase().includes(original_filename))
                    this.fileName.writeUtf16String('meow');
            }   
        }
      },
    });

    const NtCreateFile = Module.getExportByName('ntdll.dll', 'NtCreateFile');
    Interceptor.attach(NtCreateFile, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[2].add(8).readPointer().add(4).readPointer(); //ObjectAttributes->ObjectName->Buffer
        console.log(this.fileName.readUtf16String());
        for (let f of all_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] NtCreateFile - file checked: ${this.fileName.readUtf16String()}`);
                if (!this.fileName.readUtf16String().toLowerCase().includes(original_filename))
                    this.fileName.writeUtf16String('meow');
                //console.log(this.fileName.readUtf16String());
            }   
        }
      },
    });

    const NtQueryAttributesFile = Module.getExportByName('ntdll.dll', 'NtQueryAttributesFile');
    Interceptor.attach(NtQueryAttributesFile, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileName = args[0].add(8).readPointer().add(4).readPointer(); //ObjectAttributes->ObjectName->Buffer
        console.log(this.fileName.readUtf16String());
        for (let f of all_blacklist)
        {
            if (this.fileName.readUtf16String().toLowerCase().includes(f))
            {
                send(`[Filesystem] NtQueryAttributesFile - file checked: ${this.fileName.readUtf16String()}`);
                if (!this.fileName.readUtf16String().toLowerCase().includes(original_filename))
                    this.fileName.writeUtf16String('meow');
                //console.log(this.fileName.readUtf16String());
            }   
        }
      },
    });

    //needs fix
    /* const NtQueryDirectoryFileEx = Module.getExportByName('ntdll.dll', 'NtQueryDirectoryFileEx');
    Interceptor.attach(NtQueryDirectoryFileEx, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.fileInfoClass = args[7]; //FILE_INFORMATION_CLASS FileInformationClass
        this.fileInfo = args[5]; //PVOID FileInformation
        this.offset = 0; //offset to the filename field

        if (this.fileInfoClass.toInt32() === 1) //1 FileDirectoryInformation
            this.offset = 64; //WCHAR FileName
        if (this.fileInfoClass.toInt32() === 2) //2 FileFullDirectoryInformation
            this.offset = 68; //WCHAR FileName
        if (this.fileInfoClass.toInt32() === 3) //3 FileBothDirectoryInformation
            this.offset = 73; //WCHAR ShortName[12]
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let NextEntryOffset = this.fileInfo.readU32();
        //while there are still files in the list (this should be fixed because it skips the first file)
        while (NextEntryOffset != 0) //ULONG NextEntryOffset
        {
            //console.log(NextEntryOffset);
            let fileName = this.fileInfo.add(NextEntryOffset).add(this.offset).readPointer().readUtf16String();
            console.log(fileName);
            for (let f of all_blacklist)
            {
                if (fileName.toLowerCase().includes(f))
                {
                    send(`[Filesystem] NtQueryDirectoryFileEx - file checked: ${fileName}`);
                    this.sysInfo.add(NextEntryOffset).add(this.offset).readPointer().writeUtf16String('meow');
                }
            }
                
            let newOffset = this.fileInfo.add(NextEntryOffset).readU32();
            if (newOffset != 0)
                NextEntryOffset = NextEntryOffset + newOffset;
            else
                NextEntryOffset = 0;
        }
      }
    }); */

    const FindFirstFileA = Module.getExportByName('Kernel32.dll', 'FindFirstFileA');
    Interceptor.attach(FindFirstFileA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let fileName = args[0].readAnsiString(); //LPCSTR lpFileName
        let to_check = fileName !== null ? fileName.toLowerCase() : '0123456789';
        for (let f of all_blacklist) {
            if (to_check.includes(f))
            {
                send("[Filesystem] FindFirstFile - replaced file: " + fileName);
                //replace the file's name if blacklisted
                const dummyFile = Memory.allocAnsiString('meow');
                this.dummyFile = dummyFile;
                args[0] = dummyFile;
            }
        }
      }
    });

    const FindFirstFileW = Module.getExportByName('Kernel32.dll', 'FindFirstFileW');
    Interceptor.attach(FindFirstFileW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let fileName = args[0].readUtf16String(); //LPCWSTR lpFileName
        let to_check = fileName !== null ? fileName.toLowerCase() : '0123456789';
        for (let f of all_blacklist) {
            if (to_check.includes(f))
            {
                send("[Filesystem] FindFirstFile - replaced file: " + fileName);
                //replace the file's name if blacklisted
                const dummyFile = Memory.allocUtf16String('meow');
                this.dummyFile = dummyFile;
                args[0] = dummyFile;
            }
        }
      }
    });

    const FindFirstFileExA = Module.getExportByName('Kernel32.dll', 'FindFirstFileExA');
    Interceptor.attach(FindFirstFileExA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let fileName = args[0].readAnsiString(); //LPCSTR lpFileName
        let to_check = fileName !== null ? fileName.toLowerCase() : '0123456789';
        for (let f of all_blacklist) {
            if (to_check.includes(f))
            {
                send("[Filesystem] FindFirstFile - replaced file: " + fileName);
                //replace the file's name if blacklisted
                const dummyFile = Memory.allocAnsiString('meow');
                this.dummyFile = dummyFile;
                args[0] = dummyFile;
            }
        }
      }
    });

    const FindFirstFileExW = Module.getExportByName('Kernel32.dll', 'FindFirstFileExW');
    Interceptor.attach(FindFirstFileExW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let fileName = args[0].readUtf16String(); //LPCWSTR lpFileName
        let to_check = fileName !== null ? fileName.toLowerCase() : '0123456789';
        for (let f of all_blacklist) {
            if (to_check.includes(f))
            {
                send("[Filesystem] FindFirstFile - replaced file: " + fileName);
                //replace the file's name if blacklisted
                const dummyFile = Memory.allocUtf16String('meow');
                this.dummyFile = dummyFile;
                args[0] = dummyFile;
            }
        }
      }
    });

    const FindNextFileA = Module.getExportByName('Kernel32.dll', 'FindNextFileA');
    Interceptor.attach(FindNextFileA, {
      onEnter(args) {
        this.outStruct = args[1]; //LPWIN32_FIND_DATAA lpFindFileData
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toInt32() !== 0)
        {
            let fileName = this.outStruct.add(44).readCString(); //CHAR cFileName[MAX_PATH];
            for (let f of all_blacklist) {
                if (fileName.toLowerCase().includes(f))
                {
                    send("[Filesystem] FindNextFile - replaced file: " + fileName);
                    //replace the file's name if blacklisted
                    this.outStruct.add(44).writeUtf8String('meow');
                    console.log(this.outStruct.add(44).readCString())
                }
            }
        }
      }
    });

    const FindNextFileW = Module.getExportByName('Kernel32.dll', 'FindNextFileW');
    Interceptor.attach(FindNextFileW, {
      onEnter(args) {
        this.outStruct = args[1]; //LPWIN32_FIND_DATAW lpFindFileData
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toInt32() !== 0)
        {
            let fileName = this.outStruct.add(44).readUtf16String(); //WCHAR cFileName[MAX_PATH];
            for (let f of all_blacklist) {
                if (fileName.toLowerCase().includes(f))
                {
                    send("[Filesystem] FindNextFile - replaced file: " + fileName);
                    //replace the file's name if blacklisted
                    this.outStruct.add(44).writeUtf16String('meow');
                    console.log(this.outStruct.add(44).readUtf16String())
                }
            }
        }
      }
    });

    try {
        const MsiGetProductInfoA = Module.getExportByName('Msi.dll', 'MsiGetProductInfoA');
        Interceptor.attach(MsiGetProductInfoA, {
        onEnter(args) {
            this.property = args[1].readAnsiString(); //LPCSTR szAttribute
            this.productName = args[2]; //LPSTR lpValueBuf
            console.log(this.property);
        },

        onLeave() {
            if (!appModules.has(this.returnAddress) && onlyAppCode)
                return;
            if (this.property === "INSTALLPROPERTY_INSTALLEDPRODUCTNAME")
            {
                for (let p of products_blacklist)
                {
                    if (this.productName.readAnsiString().toLowerCase().includes(p))
                    {
                        send(`[Filesystem] MsiGetProductInfo - replaced product: ${this.productName.readAnsiString()}`);
                        this.productName.writeAnsiString('meow');
                        console.log(this.productName.readAnsiString());
                    }   
                }
            }
        }
        });

        const MsiGetProductInfoW = Module.getExportByName('Msi.dll', 'MsiGetProductInfoW');
        Interceptor.attach(MsiGetProductInfoW, {
        onEnter(args) {
            this.property = args[1].readUtf16String(); //LPCWSTR szAttribute
            this.productName = args[2]; //LPWSTR lpValueBuf
            console.log(this.property);
        },

        onLeave() {
            if (!appModules.has(this.returnAddress) && onlyAppCode)
                return;
            if (this.property === "INSTALLPROPERTY_INSTALLEDPRODUCTNAME")
            {
                for (let p of products_blacklist)
                {
                    if (this.productName.readUtf16String().toLowerCase().includes(p))
                    {
                        send(`[Filesystem] MsiGetProductInfo - replaced product: ${this.productName.readUtf16String()}`);
                        this.productName.writeUtf16String('meow');
                        console.log(this.productName.readUtf16String());
                    }   
                }
            }
        }
        });

        const MsiGetProductInfoExA = Module.getExportByName('Msi.dll', 'MsiGetProductInfoExA');
        Interceptor.attach(MsiGetProductInfoExA, {
        onEnter(args) {
            this.property = args[3].readAnsiString(); //LPCSTR szAttribute
            this.productName = args[4]; //LPSTR lpValueBuf
            console.log(this.property);
        },

        onLeave() {
            if (!appModules.has(this.returnAddress) && onlyAppCode)
                return;
            if (this.property === "INSTALLPROPERTY_INSTALLEDPRODUCTNAME")
            {
                for (let p of products_blacklist)
                {
                    if (this.productName.readAnsiString().toLowerCase().includes(p))
                    {
                        send(`[Filesystem] MsiGetProductInfo - replaced product: ${this.productName.readAnsiString()}`);
                        this.productName.writeAnsiString('meow');
                        console.log(this.productName.readAnsiString());
                    }   
                }
            }
        }
        });

        const MsiGetProductInfoExW = Module.getExportByName('Msi.dll', 'MsiGetProductInfoExW');
        Interceptor.attach(MsiGetProductInfoExW, {
        onEnter(args) {
            this.property = args[3].readUtf16String(); //LPCWSTR szAttribute
            this.productName = args[4]; //LPWSTR lpValueBuf
            console.log(this.property);
        },

        onLeave() {
            if (!appModules.has(this.returnAddress) && onlyAppCode)
                return;
            if (this.property === "INSTALLPROPERTY_INSTALLEDPRODUCTNAME")
            {
                for (let p of products_blacklist)
                {
                    if (this.productName.readUtf16String().toLowerCase().includes(p))
                    {
                        send(`[Filesystem] MsiGetProductInfo - replaced product: ${this.productName.readUtf16String()}`);
                        this.productName.writeUtf16String('meow');
                        console.log(this.productName.readUtf16String());
                    }   
                }
            }
        }
        });
    } catch (error) {
        console.log(error);
    }

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
