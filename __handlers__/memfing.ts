/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */
    
    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));

    //https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm
    const BeingDebuggedOffset = 0x02;
    const NumberOfProcessorsOffset = Process.pointerSize === 4 ? 0x64 : 0xB8;
    const NtGlobalFlagOffset = Process.pointerSize === 4 ? 0x68 : 0xBC;
    const ProcessHeapOffset = Process.pointerSize === 4 ? 0x18 : 0x30;
    const ProcessHeapFlagsOffset = Process.pointerSize === 4 ? 0x40 : 0x70;
    const ProcessHeapForceFlagsOffset = Process.pointerSize === 4 ? 0x44 : 0x74;

    const KUSER_SHARED_DATA = ptr('0x7FFE0000');
    const KdDebuggerEnabledOffset = 0x2D4;
    const InterruptTimeOffset = 0x8;
    const SystemTimeOffset = 0x14;
    const TickCountQuadOffset = 0x320;

    const addr_RtlGetCurrentPeb = Module.getExportByName('ntdll.dll', 'RtlGetCurrentPeb');
    const fun_RtlGetCurrentPeb = new NativeFunction(addr_RtlGetCurrentPeb, 'pointer', []);

    //Reminder: always use const when passing allocated buffers to NativeFunctions
    const pebAddress = fun_RtlGetCurrentPeb();


    function kusershdDebuggerEnabled()
    {
        MemoryAccessMonitor.enable({base: KUSER_SHARED_DATA, size: Process.pageSize}, {
            onAccess: function (details) {
                console.log(details.operation, details.from, details.address);
                if (details.address.equals(KUSER_SHARED_DATA.add(KdDebuggerEnabledOffset)) &&
                    appModules.has(details.from))
                {
                    send("[Memory Fingerprinting] KUSER_SHARED_DATA->KdDebuggerEnabled");
                    //patch the calling code somehow
                }
                else if (details.address.equals(KUSER_SHARED_DATA.add(InterruptTimeOffset)) &&
                         appModules.has(details.from))
                {
                    send("[Timing] KUSER_SHARED_DATA->InterruptTime");
                    //patch the calling code somehow
                }
                else if (details.address.equals(KUSER_SHARED_DATA.add(SystemTimeOffset)) &&
                         appModules.has(details.from))
                {
                    send("[Timing] KUSER_SHARED_DATA->SystemTime");
                    //patch the calling code somehow
                }
                else if (details.address.equals(KUSER_SHARED_DATA.add(TickCountQuadOffset)) &&
                         appModules.has(details.from))
                {
                    send("[Timing] KUSER_SHARED_DATA->TickCountQuad");
                    //patch the calling code somehow
                }

                //start monitoring again
                kusershdDebuggerEnabled();
            },
        });
    }

    function pebMonitor()
    {
        MemoryAccessMonitor.enable({base: pebAddress, size: Process.pageSize}, {
            onAccess: function (details) {
                console.log(details.operation, details.from, details.address);
                //console.log(Instruction.parse(details.address).toString());
                console.log(details.address);
                //the second check is not necessary since the structure is read-only
                if (details.address.equals(pebAddress.add(BeingDebuggedOffset)) &&
                    appModules.has(details.from))
                    send("[Memory Fingerprinting] PEB->BeingDebugged");
                else if (details.address.equals(pebAddress.add(NumberOfProcessorsOffset)) &&
                         appModules.has(details.from))
                    send("[System Environment] PEB->NumberOfProcessors");
                else if (details.address.equals(pebAddress.add(NtGlobalFlagOffset)) &&
                         appModules.has(details.from))
                    send("[Memory Fingerprinting] PEB->NtGlobalFlag");
                else if (details.address.equals(pebAddress.add(ProcessHeapOffset).add(ProcessHeapFlagsOffset)) &&
                         appModules.has(details.from))
                    send("[Memory Fingerprinting] PEB->ProcessHeap->Flags");
                else if (details.address.equals(pebAddress.add(ProcessHeapOffset).add(ProcessHeapForceFlagsOffset)) &&
                         appModules.has(details.from))
                    send("[Memory Fingerprinting] PEB->ProcessHeap->ForceFlags");
                
                //start monitoring again
                pebMonitor();
            },
        });
    }

    kusershdDebuggerEnabled();
    pebMonitor();

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
