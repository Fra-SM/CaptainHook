/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */

    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));

    const NtSetInformationThread = Module.getExportByName('ntdll.dll', 'NtSetInformationThread');
    Interceptor.attach(NtSetInformationThread, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.threadInfoClass = args[1]; //THREADINFOCLASS ThreadInformationClass
        if (this.threadInfoClass.toInt32() === 17) //ThreadHideFromDebugger
        {
            send("[Process Environment] NtSetInformationThread(0x11)");
            /* //change thread priority to normal instead
            args[1].writeInt(2);
            args[2].writeInt(0); */
        }
      }
    });

    const NtCreateThreadEx = Module.getExportByName('ntdll.dll', 'NtCreateThreadEx');
    Interceptor.attach(NtCreateThreadEx, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.threadCreateFlags = args[6]; //ULONG CreateFlags
        if (this.threadCreateFlags.toInt32() === 4) //THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004
        {
            send("[Process Environment] NtCreateThreadEx(HIDE_FROM_DEBUGGER)");
            //change the flag to 0x00000002 (THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH)
            this.threadCreateFlags.writeU32(2);
        }
      }
    });

    const NtGetContextThread = Module.getExportByName('ntdll.dll', 'NtGetContextThread');
    Interceptor.attach(NtGetContextThread, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.contextStruct = args[1]; //PCONTEXT pContext
        if (this.contextStruct.add(48).readUInt() === 1048592) //CONTEXT_DEBUG_REGISTERS
        {
            send("[Process Environment] NtGetContextThread(CONTEXT_DEBUG_REGISTERS)");
            //set hardware breakpoints registers to 0 (DR0 to DR3)
            this.contextStruct.add(72).writeULong(0); //DR0
            this.contextStruct.add(80).writeULong(0); //DR1
            this.contextStruct.add(88).writeULong(0); //DR2
            this.contextStruct.add(96).writeULong(0); //DR3
            //console.log(this.contextStruct.add(72).readULong());
        }
      }
    });

    const GetThreadContext = Module.getExportByName('Kernel32.dll', 'GetThreadContext');
    Interceptor.attach(GetThreadContext, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.contextStruct = args[1]; //PCONTEXT pContext
        //console.log(this.contextStruct.add(48).readInt());
        if (this.contextStruct.add(48).readUInt() === 1048592) //CONTEXT_DEBUG_REGISTERS
        {
            send("[Process Environment] GetThreadContext(CONTEXT_DEBUG_REGISTERS)");
            //set hardware breakpoints registers to 0 (DR0 to DR3)
            this.contextStruct.add(72).writeULong(0); //DR0
            this.contextStruct.add(80).writeULong(0); //DR1
            this.contextStruct.add(88).writeULong(0); //DR2
            this.contextStruct.add(96).writeULong(0); //DR3
            //console.log(this.contextStruct.add(72).readULong());
        }
      }
    });

    const NtSetContextThread = Module.getExportByName('ntdll.dll', 'NtSetContextThread');
    Interceptor.attach(NtSetContextThread, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.contextStruct = args[1]; //PCONTEXT pContext
        if (this.contextStruct.add(48).readUInt() === 1048592) //CONTEXT_DEBUG_REGISTERS
        {
            send("[Process Environment] NtSetContextThread(CONTEXT_DEBUG_REGISTERS)");
        }
      }
    });

    //generated a lot of noise, fixed as in stalling
    const NtQueryInformationProcess = Module.getExportByName('ntdll.dll', 'NtQueryInformationProcess');
    Interceptor.attach(NtQueryInformationProcess, {
      onEnter(args) {
        this.procInfoClass = args[1].toInt32(); //PROCESSINFOCLASS ProcessInformationClass
        this.outputInfo = args[2]; //PVOID ProcessInformation
        this.pbi = false; //processbasicinformation
        this.pdp = false; //processdebugport
        this.pdoh = false; //processdebugobjecthandle
        this.pdf = false;  //processdebugflags

        if (this.procInfoClass === 0)
            this.pbi = true;
        if (this.procInfoClass === 7) //ProcessDebugPort
            this.pdp = true;
        if (this.procInfoClass === 30) //ProcessDebugObjectHandle
            this.pdoh = true;
        if (this.procInfoClass === 31) //ProcessDebugFlags
            this.pdf = true;
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        if (this.pbi)
        {
            this.outputInfo.add(20).writeInt(333); //set parent pid to fake value, should probably check this exists
            send("[Others] NtQueryInformationProcess(ProcessBasicInformation/0x0) - IsParentExplorerExe");
        }
        if (this.pdp)
        {
            this.outputInfo.writeInt(0); //set debugging flag to 0
            send("[Process Environment] NtQueryInformationProcess(ProcessDebugPort/0x7)");
        }
        if (this.pdoh)
        {
            this.outputInfo.writeInt(0); //set debugging flag to 0
            send("[Process Environment] NtQueryInformationProcess(ProcessDebugObjectHandle/0x1e)");
        }  
        if (this.pdf)
        {
            this.outputInfo.writeInt(1); //set debugging flag to 1
            send("[Process Environment] NtQueryInformationProcess(ProcessDebugFlags/0x1f)");
        }
      }
    });

    //child-gating feature should be enabled for this to work
    const DebugActiveProcess = Module.getExportByName('Kernel32.dll', 'DebugActiveProcess');
    Interceptor.attach(DebugActiveProcess, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.pid = args[0].toUInt32(); //DWORD dwProcessId
        if (this.pid === process.ppid) //check if the child process is trying to debug its parent
            send(`[Process Environment] DebugActiveProcess(PARENT_PID=${this.pid})`);
      }
    });

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }