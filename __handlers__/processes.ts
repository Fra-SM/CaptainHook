/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */
  
    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));
    const onlyAppCode = true;

    let processes_blacklist = [
        "vbox",
        "vmware",
        "vgauthservice",
        "vmacthlp",
        "vmtoolsd",
        "vmount2",
        "prl_cc",
        "prl_tools",
        "ollydbg",					 // OllyDebug debugger
        "processhacker",			 // Process Hacker
        "tcpview",					 // Part of Sysinternals Suite
        "autoruns",					 // Part of Sysinternals Suite
        "filemon",					 // Part of Sysinternals Suite
        "procmon",					 // Part of Sysinternals Suite
        "regmon",					 // Part of Sysinternals Suite
        "procexp",					 // Part of Sysinternals Suite
        "ida",						 // IDA Pro Interactive Disassembler
        "immunitydebugger",			 // ImmunityDebugger
        "wireshark",				 // Wireshark packet sniffer
        "dumpcap",					 // Network traffic dump tool
        "hookexplorer",				 // Find various types of runtime hooks
        "importrec",				 // Import Reconstructor
        "petools",					 // PE Tool
        "lordpe",					 // LordPE
        "sysinspector",				 // ESET SysInspector
        "proc_analyzer",			 // Part of SysAnalyzer iDefense
        "sysanalyzer",				 // Part of SysAnalyzer iDefense
        "sniff_hit",				 // Part of SysAnalyzer iDefense
        "windbg",					 // Microsoft WinDbg
        "joebox",                    // Joe Sandbox
        "resourcehacker",			 // Resource Hacker
        "x32dbg",					 // x32dbg
        "x64dbg",					 // x64dbg
        "fiddler",					 // Fiddler
        "httpdebugger",				 // Http Debugger
        "netmon",					 // Part of Sysinternals Suite
        "ghidra",
        "tcpdump",
        "netstat",					 
        "cain",						 
        "httpanalyzerstdv7",
        "apimonitor",
        "scylla",	
        "cheatengine",
        "frida"
        ];

    //should be rewritten to separate checks and replacing actions
    function checkEmulationProcesses(process, isUtf16)
    {
      if (!isUtf16)
      {
        let to_check1 = process.readUtf8String().toLowerCase();
        if (to_check1.includes("vmsrvc") ||
            to_check1.includes("vmusrvc"))
        {
            send("[Emulation] VirtualPC - process checked: ", process.readUtf8String());
            process.writeUtf8String('meow');
        }
        if (to_check1.includes("xenservice") ||
            to_check1.includes("xsvc_depriv"))
        {
            send("[Emulation] Xen - process checked: ", process.readUtf8String());
            process.writeUtf8String('meow');
        }
        if (to_check1.includes("qemu"))
        {
            send("[Emulation] QEMU - process checked: ", process.readUtf8String());
            process.writeUtf8String('meow');
        }
      }

      else
      {
        let to_check2 = process.readUtf16String().toLowerCase();
        if (to_check2.includes("vmsrvc") ||
            to_check2.includes("vmusrvc"))
        {
            send("[Emulation] VirtualPC - process checked: ", process.readUtf16String());
            process.writeUtf16String('meow');
        }
        if (to_check2.includes("xenservice") ||
            to_check2.includes("xsvc_depriv"))
        {
            send("[Emulation] Xen - process checked: ", process.readUtf16String());
            process.writeUtf16String('meow');
        }
        if (to_check2.includes("qemu"))
        {
            send("[Emulation] QEMU - process checked: ", process.readUtf16String());
            process.writeUtf16String('meow');
        }
      }
    }

    
    //we put "null" as these APIs can reside in different modules depending on the Windows version
    const EnumProcesses = Module.getExportByName(null, 'EnumProcesses');
    Interceptor.attach(EnumProcesses, {
      onEnter() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Processes] EnumProcesses");
      }
    });

    const GetModuleBaseNameA = Module.getExportByName(null, 'GetModuleBaseNameA');
    Interceptor.attach(GetModuleBaseNameA, {
      onEnter(args) {
        this.lpBaseName = args[2]; //LPSTR lpBaseName
        this.process = this.lpBaseName.readAnsiString(); //string pointed to
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        for (let p of processes_blacklist) {
            if (this.process.toLowerCase().includes(p))
            {
                send("[Processes] GetModuleBaseName - process checked: " + this.process);
                //replace the process' name if blacklisted
                this.lpBaseName.writeAnsiString('meow');
                //console.log(this.lpBaseName.readAnsiString());
            }       
        }

        checkEmulationProcesses(this.lpBaseName, false);
      }
    });

    const GetModuleBaseNameW = Module.getExportByName(null, 'GetModuleBaseNameW');
    Interceptor.attach(GetModuleBaseNameW, {
      onEnter(args) {
        this.lpBaseName = args[2]; //LPWSTR lpBaseName
        this.process = this.lpBaseName.readUtf16String(); //string pointed to
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        for (let p of processes_blacklist) {
            if (this.process.toLowerCase().includes(p))
            {
                send("[Processes] GetModuleBaseName - process checked: " + this.process);
                //replace the process' name if blacklisted
                this.lpBaseName.writeUtf16String('meow');
                //console.log(this.lpBaseName.readUtf16String());
            }       
        }

        checkEmulationProcesses(this.lpBaseName, true);
      }
    });

    const Process32First = Module.getExportByName('Kernel32.dll', 'Process32First');
    Interceptor.attach(Process32First, {
      onEnter(args) {
        this.szName = args[1].add(36); //CHAR szExeFile[MAX_PATH];
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        for (let p of processes_blacklist) {
            if (this.szName.readCString().toLowerCase().includes(p))
            {
                send("[Processes] Process32First - replaced process: " + this.szName.readCString());
                //replace the process' name if blacklisted
                this.szName.writeUtf8String('meow');
                //console.log(this.szName.readUtf8String());
            }       
        }

        checkEmulationProcesses(this.szName, false);
      }
    });

    const Process32FirstW = Module.getExportByName('Kernel32.dll', 'Process32FirstW');
    Interceptor.attach(Process32FirstW, {
      onEnter(args) {
        this.szName = args[1].add(36); //WCHAR szExeFile[MAX_PATH];
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        for (let p of processes_blacklist) {
            if (this.szName.readUtf16String().toLowerCase().includes(p))
            {
                send("[Processes] Process32First - replaced process: " + this.szName.readUtf16String());
                //replace the process' name if blacklisted
                this.szName.writeUtf16String('meow');
                //console.log(this.szName.readUtf16String());
            }       
        }

        checkEmulationProcesses(this.szName, true);
      }
    });

    const Process32Next = Module.getExportByName('Kernel32.dll', 'Process32Next');
    Interceptor.attach(Process32Next, {
      onEnter(args) {
        this.szName = args[1].add(36); //CHAR szExeFile[MAX_PATH];
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        for (let p of processes_blacklist) {
            if (this.szName.readCString().toLowerCase().includes(p))
            {
                send("[Processes] Process32Next - replaced process: " + this.szName.readCString());
                //replace the process' name if blacklisted
                this.szName.writeUtf8String('meow');
                //console.log(this.szName.readUtf8String());
            }       
        }

        checkEmulationProcesses(this.szName, false);
      }
    });

    const Process32NextW = Module.getExportByName('Kernel32.dll', 'Process32NextW');
    Interceptor.attach(Process32NextW, {
      onEnter(args) {
        this.szName = args[1].add(36); //WCHAR szExeFile[MAX_PATH];
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        for (let p of processes_blacklist) {
            if (this.szName.readUtf16String().toLowerCase().includes(p))
            {
                send("[Processes] Process32Next - replaced process: " + this.szName.readUtf16String());
                //replace the process' name if blacklisted
                this.szName.writeUtf16String('meow');
                //console.log(this.szName.readUtf16String());
            }       
        }

        checkEmulationProcesses(this.szName, true);
      }
    });

    const GetProcAddress = Module.getExportByName('Kernel32.dll', 'GetProcAddress');
    Interceptor.attach(GetProcAddress, {
      onEnter(args) {
        this.procedure = args[1]; //LPCSTR lpProcName
      },
   
      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) &&
            onlyAppCode) || 
            this.procedure.isNull())
            return;
        if (this.procedure.readAnsiString().toLowerCase().includes("wine"))
        {
            send("[Emulation] Wine - procedure checked: ", this.procedure.readAnsiString());
            //replace the return value with NULL
            retval.replace(NULL);
        }       
      }
    });

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
