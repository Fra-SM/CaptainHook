/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */

    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));
    const onlyAppCode = true;

    function handleSuspiciousRegEntry(infoClass, keyInfoStruct, type, dataOffset, dataLength, nameLength, name, namePtr)
    {
        console.log(name);
        for (let r of registry_blacklist)
            if (name.toLowerCase().includes(r))
                return true;
        
        let value;
        let valueLen;

        if (infoClass === 1 || infoClass === 3)
        {
            value = keyInfoStruct.add(dataOffset);
            valueLen = dataLength;
        }
        else
        {
            value = namePtr;
            valueLen = dataLength;
        }

        //REG_SZ or REG_EXPAND_SZ
        if (type === 1 || type === 2)
            for (let r of registry_blacklist)
                if (value.readUtf16String(valueLen).toLowerCase().includes(r))
                {
                    console.log(value.readUtf16String());
                    return true;
                }
                    
        //REG_MULTI_SZ
        else if (type === 7)
        {
            var len = 0;
            while (len < valueLen)
            {
                let cur_str = value.readUtf16String();
                for (let r of registry_blacklist)
                if (cur_str.toLowerCase().includes(r))
                {
                    console.log(cur_str);
                    return true;
                }
                len += cur_str.length;
            }
        }

        return false;
    }

    let registry_blacklist = [
        "vbox", //Virtual Box
        "virtualbox",
        "vmware", //VMWare
        "vmtools",
        "vmmemctl",
        "vmci",
        "vmx86",
        "vmdebug",
        "vmmouse",
        "vm3dmp",
        "vmx_svga",
        "ven_1ab8", //Parallels
        "parallels",
        "bochs", //Bochs
        "vmic", //Hyper-V
        "virtualmachine",
        "virtual machine",
        "hyper",
        "sandboxie", //Sandboxie
        "sbiedrv",
        "debug",
        "computername",
        "image file execution options",
        "ntice",
        "sice",
        "hardware\\description\\system"
    ];

    function checkEmulationRegistry(reg, func, isUtf16)
    {
        if (!isUtf16)
        {
            let to_check1 = reg.readAnsiString().toLowerCase();
            if (to_check1.includes("vpcbus") ||
                to_check1.includes("vpcuhub") ||
                to_check1.includes("vpc-s3") ||
                to_check1.includes("msvmmouf") ||
                to_check1.includes("ven_5333"))
            {
                send(`[Emulation] VirtualPC - registry key checked via ${func}: ${reg.readAnsiString()}`);
                reg.writeAnsiString('meow');
            }
            if (to_check1.includes("xen"))
            {
                send(`[Emulation] Xen - registry key checked via ${func}: ${reg.readAnsiString()}`);
                reg.writeAnsiString('meow');
            }
            if (to_check1.includes("qemu"))
            {
                send(`[Emulation] QEMU - registry key checked via ${func}: ${reg.readAnsiString()}`);
                reg.writeAnsiString('meow');
            }
            if (to_check1.includes("wine"))
            {
                send(`[Emulation] Wine - registry key checked via ${func}: ${reg.readAnsiString()}`);
                reg.writeAnsiString('meow');
            }
        }
        else
        {
            let to_check2 = reg.readUtf16String().toLowerCase();
            if (to_check2.includes("vpcbus") ||
                to_check2.includes("vpcuhub") ||
                to_check2.includes("vpc-s3") ||
                to_check2.includes("msvmmouf") ||
                to_check2.includes("ven_5333"))
            {
                send(`[Emulation] VirtualPC - registry key checked via ${func}: ${reg.readUtf16String()}`);
                reg.writeUtf16String('meow');
            }
            if (to_check2.includes("xen"))
            {
                send(`[Emulation] Xen - registry key checked via ${func}: ${reg.readUtf16String()}`);
                reg.writeUtf16String('meow');
            }
            if (to_check2.includes("qemu"))
            {
                send(`[Emulation] QEMU - registry key checked via ${func}: ${reg.readUtf16String()}`);
                reg.writeUtf16String('meow');
            }
            if (to_check2.includes("wine"))
            {
                send(`[Emulation] Wine - registry key checked via ${func}: ${reg.readUtf16String()}`);
                reg.writeUtf16String('meow');
            }
        }    
    }

    /* typedef struct _OBJECT_ATTRIBUTES {
        ULONG           Length;
        HANDLE          RootDirectory;
        PUNICODE_STRING ObjectName;
        ULONG           Attributes;
        PVOID           SecurityDescriptor;
        PVOID           SecurityQualityOfService;
      } OBJECT_ATTRIBUTES; */

    /* typedef struct _UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;
      } UNICODE_STRING, *PUNICODE_STRING; */
    const NtOpenKey = Module.getExportByName('ntdll.dll', 'NtOpenKey');
    Interceptor.attach(NtOpenKey, {
      onEnter(args) {
        //this prevents also calls happening via the higher level API RegOpenKey to be logged
        //hooks for such higher-level APIs should be defined separately
        if ((!appModules.has(this.returnAddress) && onlyAppCode) || 
            args[2].isNull())
            return;
        //x32/x64 supported
        this.regKey = args[2].add(4 + Process.pointerSize).readPointer().add(4).readPointer(); //ObjectAttributes->ObjectName->Buffer
        console.log(this.regKey.readUtf16String());
        for (let r of registry_blacklist)
        {
            if (this.regKey.readUtf16String().toLowerCase().includes(r))
            {
                send("[Registry] NtOpenKey - replaced: " + this.regKey.readUtf16String());
                this.regKey.writeUtf16String('meow');
                console.log(this.regKey.readUtf16String());
            }   
        }
        
        checkEmulationRegistry(this.regKey, "NtOpenKey", true);
      },
    });

    const NtOpenKeyEx = Module.getExportByName('ntdll.dll', 'NtOpenKeyEx');
    Interceptor.attach(NtOpenKeyEx, {
      onEnter(args) {
        //this prevents also calls happening via the higher level API RegOpenKey to be logged
        //hooks for such higher-level APIs should be defined separately
        if ((!appModules.has(this.returnAddress) && onlyAppCode) || 
            args[2].isNull())
            return;
        //x32/x64 supported
        this.regKey = args[2].add(4 + Process.pointerSize).readPointer().add(4).readPointer(); //ObjectAttributes->ObjectName->Buffer
        console.log(this.regKey.readUtf16String());
        for (let r of registry_blacklist)
        {
            if (this.regKey.readUtf16String().toLowerCase().includes(r))
            {
                send("[Registry] NtOpenKey - replaced: " + this.regKey.readUtf16String());
                this.regKey.writeUtf16String('meow');
                console.log(this.regKey.readUtf16String());
            }   
        }
        
        checkEmulationRegistry(this.regKey, "NtOpenKey", true);
      },
    });

    /* typedef struct _KEY_BASIC_INFORMATION {
        LARGE_INTEGER LastWriteTime;
        ULONG         TitleIndex;
        ULONG         NameLength;
        WCHAR         Name[1];
      } KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION; */

    /* typedef struct _KEY_NODE_INFORMATION {
        LARGE_INTEGER LastWriteTime;
        ULONG         TitleIndex;
        ULONG         ClassOffset;
        ULONG         ClassLength;
        ULONG         NameLength;
        WCHAR         Name[1];
      } KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION; */

    //KEY_FULL_INFORMATION does not contain info about the key's name
    const NtEnumerateKey = Module.getExportByName('ntdll.dll', 'NtEnumerateKey');
    Interceptor.attach(NtEnumerateKey, {
      onEnter(args) {
        this.keyInfoClass = args[2].toInt32(); //KEY_INFORMATION_CLASS
        this.keyInfo = args[3]; //PVOID output KeyInformation
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) &&
            onlyAppCode) ||
            (retval.toInt32() != 0 && retval.toInt32() != 2147483674)) //STATUS_SUCCESS and STATUS_NO_MORE_ENTRIES
            return;
        var to_check;
        switch (this.keyInfoClass) {
            //KeyBasicInformation
            case 0: {
                var stringOffset = 16;
                var len = this.keyInfo.add(12).readU32();
                //console.log(len);
                to_check = this.keyInfo.add(stringOffset).readPointer().readUtf16String(len);
                break;
            }
            //KeyNodeInformation
            case 1: {
                var stringOffset = 24;
                var len = this.keyInfo.add(20).readU32();
                //console.log(len);
                to_check = this.keyInfo.add(stringOffset).readPointer().readUtf16String(len);
                break;
            } 
            default:
                return;
        }

        console.log(to_check);
        for (let r of registry_blacklist)
        {
            if (to_check.toLowerCase().includes(r))
            {
                send("[Registry] NtEnumerateKey - replaced: " + to_check);
                this.keyInfo.add(stringOffset).readPointer().writeUtf16String("meow");
            }
        }

        checkEmulationRegistry(this.keyInfo.add(stringOffset).readPointer(), "NtEnumerateKey", true);
      }
    });

    //https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_key_value_information_class
    const NtEnumerateValueKey = Module.getExportByName('ntdll.dll', 'NtEnumerateValueKey');
    Interceptor.attach(NtEnumerateValueKey, {
      onEnter(args) {
        this.keyInfoClass = args[2].toInt32(); //KEY_INFORMATION_CLASS
        this.keyInfo = args[3]; //PVOID output KeyInformation
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            (retval.toInt32() != 0 && retval.toInt32() != 2147483674)) //STATUS_SUCCESS and STATUS_NO_MORE_ENTRIES
            return;

        var Type = this.keyInfo.add(4).readU32(); //ULONG Type (always same offset)
        var DataOffset = 0; //ULONG DataOffset
        var DataLength = 0; //ULONG DataLength
        var NameLength = 0; //ULONG NameLength
        var Name; //WCHAR Name[1]
        var NamePtr;
        switch (this.keyInfoClass) {
            //KeyValueBasicInformation
            case 0: {
                var stringOffset = 12;
                NameLength = this.keyInfo.add(8).readU32();
                Name = this.keyInfo.add(stringOffset).readPointer().readUtf16String(NameLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            //KeyValueFullInformation
            case 1: {
                var stringOffset = 20;
                DataOffset = this.keyInfo.add(8).readU32();
                DataLength = this.keyInfo.add(12).readU32();
                NameLength = this.keyInfo.add(16).readU32();
                Name = this.keyInfo.add(stringOffset).readPointer().readUtf16String(NameLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            //KeyValuePartialInformation
            case 2: {
                var stringOffset = 12;
                DataLength = this.keyInfo.add(8).readU32();
                Name = this.keyInfo.add(stringOffset).readPointer().readUtf16String(DataLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            //KeyValueFullInformationAlign64
            case 3: {
                var stringOffset = 20;
                DataOffset = this.keyInfo.add(8).readU32();
                DataLength = this.keyInfo.add(12).readU32();
                NameLength = this.keyInfo.add(16).readU32();
                Name = this.keyInfo.add(stringOffset).readPointer().readUtf16String(NameLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            //KeyValuePartialInformationAlign64
            case 4: {
                var stringOffset = 12;
                DataLength = this.keyInfo.add(8).readU32();
                Name = this.keyInfo.add(stringOffset).readPointer().readUtf16String(DataLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            default:
                return;
        }
        
        console.log(Name);
        if (handleSuspiciousRegEntry(this.keyInfoClass,this.keyInfo, Type, DataOffset, DataLength, NameLength, Name, NamePtr))
        {
            send("[Registry] NtEnumerateValueKey - replaced: " + Name);
            retval.replace(ptr(0xc0000034)); //fake STATUS_OBJECT_NAME_NOT_FOUND
        }   
      }
    });
    
    const NtQueryValueKey = Module.getExportByName('ntdll.dll', 'NtQueryValueKey');
    Interceptor.attach(NtQueryValueKey, {
      onEnter(args) {
        this.keyInfoClass = args[2].toInt32(); //KEY_INFORMATION_CLASS
        this.keyInfo = args[3]; //PVOID output KeyInformation
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            (retval.toInt32() != 0 && retval.toInt32() != 3221225524)) //STATUS_SUCCESS and STATUS_OBJECT_NAME_NOT_FOUND
            return;

        var Type = this.keyInfo.add(4).readU32(); //ULONG Type (always same offset)
        var DataOffset = 0; //ULONG DataOffset
        var DataLength = 0; //ULONG DataLength
        var NameLength = 0; //ULONG NameLength
        var Name; //WCHAR Name[1]
        var NamePtr;
        switch (this.keyInfoClass) {
            //KeyValueBasicInformation
            case 0: {
                var stringOffset = 12;
                NameLength = this.keyInfo.add(8).readU32();
                Name = this.keyInfo.add(stringOffset).readUtf16String(NameLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            //KeyValueFullInformation
            case 1: {
                var stringOffset = 20;
                DataOffset = this.keyInfo.add(8).readU32();
                DataLength = this.keyInfo.add(12).readU32();
                NameLength = this.keyInfo.add(16).readU32();
                Name = this.keyInfo.add(stringOffset).readUtf16String(NameLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            //KeyValuePartialInformation
            case 2: {
                var stringOffset = 12;
                DataLength = this.keyInfo.add(8).readU32();
                Name = this.keyInfo.add(stringOffset).readUtf16String(DataLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            //KeyValueFullInformationAlign64
            case 3: {
                var stringOffset = 20;
                DataOffset = this.keyInfo.add(8).readU32();
                DataLength = this.keyInfo.add(12).readU32();
                NameLength = this.keyInfo.add(16).readU32();
                Name = this.keyInfo.add(stringOffset).readUtf16String(NameLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            //KeyValuePartialInformationAlign64
            case 4: {
                var stringOffset = 12;
                DataLength = this.keyInfo.add(8).readU32();
                Name = this.keyInfo.add(stringOffset).readUtf16String(DataLength);
                NamePtr = this.keyInfo.add(stringOffset).readPointer();
                break;
            }
            default:
                return;
        }
        
        console.log(Name);
        if (handleSuspiciousRegEntry(this.keyInfoClass,this.keyInfo, Type, DataOffset, DataLength, NameLength, Name, NamePtr))
        {
            send("[Registry] NtQueryValueKey - replaced: " + Name);
            retval.replace(ptr(0xc0000034)); //fake STATUS_OBJECT_NAME_NOT_FOUND
        }   
      }
    });

    const RegOpenKeyA = Module.getExportByName('Advapi32.dll', 'RegOpenKeyA');
    Interceptor.attach(RegOpenKeyA, {
      onEnter(args) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            args[1].isNull())
            return;
        this.regKey = args[1]; //LPCSTR lpSubKey
        console.log(this.regKey.readAnsiString());
        for (let r of registry_blacklist)
        {
            if (this.regKey.readAnsiString().toLowerCase().includes(r))
            {
                send("[Registry] RegOpenKey - replaced: " + this.regKey.readAnsiString());
                this.regKey.writeAnsiString('meow');
                console.log(this.regKey.readAnsiString());
            }   
        }
        
        checkEmulationRegistry(this.regKey, "RegOpenKey", false);
      },
    });

    const RegOpenKeyExA = Module.getExportByName('Advapi32.dll', 'RegOpenKeyExA');
    Interceptor.attach(RegOpenKeyExA, {
      onEnter(args) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            args[1].isNull())
            return;
        this.regKey = args[1]; //LPCSTR lpSubKey
        console.log(this.regKey.readAnsiString());
        for (let r of registry_blacklist)
        {
            if (this.regKey.readAnsiString().toLowerCase().includes(r))
            {
                send("[Registry] RegOpenKey - replaced: " + this.regKey.readAnsiString());
                this.regKey.writeAnsiString('meow');
                console.log(this.regKey.readAnsiString());
            }   
        }
        
        checkEmulationRegistry(this.regKey, "RegOpenKey", false);
      },
    });

    const RegOpenKeyW = Module.getExportByName('Advapi32.dll', 'RegOpenKeyW');
    Interceptor.attach(RegOpenKeyW, {
      onEnter(args) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            args[1].isNull())
            return;
        this.regKey = args[1]; //LPCWSTR lpSubKey
        console.log(this.regKey.readUtf16String());
        for (let r of registry_blacklist)
        {
            if (this.regKey.readUtf16String().toLowerCase().includes(r))
            {
                send("[Registry] RegOpenKey - replaced: " + this.regKey.readUtf16String());
                this.regKey.writeUtf16String('meow');
                console.log(this.regKey.readUtf16String());
            }   
        }
        
        checkEmulationRegistry(this.regKey, "RegOpenKey", true);
      },
    });

    const RegOpenKeyExW = Module.getExportByName('Advapi32.dll', 'RegOpenKeyExW');
    Interceptor.attach(RegOpenKeyExW, {
      onEnter(args) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode))
            return;
        this.regKey = args[1]; //LPCWSTR lpSubKey
        console.log(this.regKey.readUtf16String());
        for (let r of registry_blacklist)
        {
            if (this.regKey.readUtf16String().toLowerCase().includes(r))
            {
                send("[Registry] RegOpenKey - replaced: " + this.regKey.readUtf16String());
                this.regKey.writeUtf16String('meow');
                console.log(this.regKey.readUtf16String());
            }   
        }
        
        checkEmulationRegistry(this.regKey, "RegOpenKey", true);
      },
    });

    const RegEnumKeyA = Module.getExportByName('Advapi32.dll', 'RegEnumKeyA');
    Interceptor.attach(RegEnumKeyA, {
      onEnter(args) {
        this.keyName = args[2]; //LPSTR lpName
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            this.keyName.isNull() ||
            retval.toInt32() != 0) //ERROR_SUCCESS
            return;

        var to_check = this.keyName.readAnsiString();
        console.log(to_check);
        for (let r of registry_blacklist)
        {
            if (to_check.toLowerCase().includes(r))
            {
                send("[Registry] RegEnumKey - replaced: " + to_check);
                this.keyName.writeAnsiString("meow");
            }
        }

        checkEmulationRegistry(this.keyName, "RegEnumKeyA", false);
      }
    });

    const RegEnumKeyW = Module.getExportByName('Advapi32.dll', 'RegEnumKeyW');
    Interceptor.attach(RegEnumKeyW, {
      onEnter(args) {
        this.keyName = args[2]; //LPWSTR lpName
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            this.keyName.isNull() ||
            retval.toInt32() != 0) //ERROR_SUCCESS
            return;

        var to_check = this.keyName.readUtf16String();
        console.log(to_check);
        for (let r of registry_blacklist)
        {
            if (to_check.toLowerCase().includes(r))
            {
                send("[Registry] RegEnumKey - replaced: " + to_check);
                this.keyName.writeUtf16String("meow");
            }
        }

        checkEmulationRegistry(this.keyName, "RegEnumKey", true);
      }
    });

    const RegEnumKeyExA = Module.getExportByName('Advapi32.dll', 'RegEnumKeyExA');
    Interceptor.attach(RegEnumKeyExA, {
      onEnter(args) {
        this.keyName = args[2]; //LPSTR lpName
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            this.keyName.isNull() ||
            retval.toInt32() != 0) //ERROR_SUCCESS
            return;

        var to_check = this.keyName.readAnsiString();
        console.log(to_check);
        for (let r of registry_blacklist)
        {
            if (to_check.toLowerCase().includes(r))
            {
                send("[Registry] RegEnumKey - replaced: " + to_check);
                this.keyName.writeAnsiString("meow");
            }
        }

        checkEmulationRegistry(this.keyName, "RegEnumKey", false);
      }
    });

    const RegEnumKeyExW = Module.getExportByName('Advapi32.dll', 'RegEnumKeyExW');
    Interceptor.attach(RegEnumKeyExW, {
      onEnter(args) {
        this.keyName = args[2]; //LPWSTR lpName
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            this.keyName.isNull() ||
            retval.toInt32() != 0) //ERROR_SUCCESS
            return;

        var to_check = this.keyName.readUtf16String();
        console.log(to_check);
        for (let r of registry_blacklist)
        {
            if (to_check.toLowerCase().includes(r))
            {
                send("[Registry] RegEnumKey - replaced: " + to_check);
                this.keyName.writeUtf16String("meow");
            }
        }

        checkEmulationRegistry(this.keyName, "RegEnumKey", true);
      }
    });

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
