/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */
  
    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));
    const onlyAppCode = true;

    const addr_CsrGetProcessId = Module.getExportByName('ntdll.dll', 'CsrGetProcessId');
    const fun_CsrGetProcessId = new NativeFunction(addr_CsrGetProcessId, 'int32', []);

    const csrssPid = fun_CsrGetProcessId();

    const SwitchDesktop = Module.getExportByName('User32.dll', 'SwitchDesktop');
    Interceptor.replace(SwitchDesktop, new NativeCallback((hDesktop) => {send("[Others] SwitchDesktop");return 0;}, 'int', ['pointer']));

    let IS_MEM_WRITE_WATCH = false;

    try {
        const SLIsGenuineLocal = Module.getExportByName("Slwga.dll", 'SLIsGenuineLocal');
        Interceptor.attach(SLIsGenuineLocal, {
          onEnter(args) {
              this.SLID = args[0].readByteArray(11); //WINDOWS_SLID is 11 bytes
              this.pGenuineState = args[1]; //SL_GENUINE_STATE *pGenuineState
          },

          onLeave(retval) {
              if ((!appModules.has(this.returnAddress) &&
                  onlyAppCode) || 
                  retval.toInt32() != 0)
                  return;
              //complete check
              /* if (this.SLID == windows_slid) */
              this.pGenuineState.writeInt(0); //fake genuine installation state
              send("[Others] SLIsGenuineLocal - Pirated Windows check");
          }
        });

        const SLIsGenuineLocalEx = Module.getExportByName("Slwga.dll", 'SLIsGenuineLocalEx');
        Interceptor.attach(SLIsGenuineLocalEx, {
          onEnter(args) {
              this.SLID = args[0].readByteArray(11); //WINDOWS_SLID is 11 bytes
              this.pGenuineState = args[2]; //SL_GENUINE_STATE *pGenuineState
          },

          onLeave(retval) {
              if ((!appModules.has(this.returnAddress) &&
                  onlyAppCode) || 
                  retval.toInt32() != 0)
                  return;
              //complete check
              //let SLID = this.SLID.isNull() ? new Uint8Array([0x0]) : new Uint8Array(this.SLID);
              /* if (SLID == WINDOWS_SLID) ... */
              this.pGenuineState.writeInt(0); //fake genuine installation state
              send("[Others] SLIsGenuineLocal - Pirated Windows check");
          }
        });
    } catch (error) {
        console.log(error);
    }
    
    try {
        const GetPwrCapabilities = Module.getExportByName("PowrProf.dll", 'GetPwrCapabilities');
        Interceptor.attach(GetPwrCapabilities, {
          onEnter(args) {
              this.powerCapabilities = args[0]; //PSYSTEM_POWER_CAPABILITIES lpspc
          },

          onLeave(retval) {
              if ((!appModules.has(this.returnAddress) &&
                  onlyAppCode) || 
                  retval.toInt32() != 0)
                  return;
              send("[Others] GetPwrCapabilities");
              //all BOOLEAN (BYTE) members
              let systemS1 = this.powerCapabilities.add(3).readU8();
              let systemS2 = this.powerCapabilities.add(4).readU8();
              let systemS3 = this.powerCapabilities.add(5).readU8();
              let systemS4 = this.powerCapabilities.add(6).readU8();
              if ((systemS1 | systemS2 | systemS3 | systemS4) == 0)
                if (this.powerCapabilities.add(13).readU8() == 0)
                {
                    this.powerCapabilities.add(13).writeU8(1);
                    console.log("GetPwrCapabilities");
                }
          }
        });
    } catch (error) {
        console.log(error);
    }

    let blockInputFlag;
    let isInsideBlockInput = false;
    let lastBlockInputRetval = false;

    const BlockInput = Module.getExportByName("User32.dll", 'BlockInput');
    Interceptor.attach(BlockInput, {
      onEnter(args) {
          this.fBlockIt = args[0].toInt32(); //BOOL fBlockIt
          blockInputFlag = this.fBlockIt;
          isInsideBlockInput = true;
      },
  
      onLeave(retval) {
          if ((!appModules.has(this.returnAddress) &&
              onlyAppCode) || 
              retval.toInt32() === 0)
              return;
          if (isInsideBlockInput && blockInputFlag)
              send("[Others] BlockInput");
          
          if (lastBlockInputRetval)
          {
              retval.replace(ptr(0));
              lastBlockInputRetval = false;
          }
          else
          {
              retval.replace(ptr(1));
              lastBlockInputRetval = true;
          }          
      }
    });

    const NtUserBlockInput = Module.getExportByName(null, 'NtUserBlockInput');
    Interceptor.attach(NtUserBlockInput, {
      onEnter(args) {
          this.fBlockIt = args[0].toInt32(); //BOOL fBlockIt
          blockInputFlag = this.fBlockIt;
          isInsideBlockInput = true;
      },
  
      onLeave(retval) {
          if ((!appModules.has(this.returnAddress) &&
              onlyAppCode) || 
              retval.toInt32() === 0)
              return;
          if (isInsideBlockInput && blockInputFlag)
              send("[Others] BlockInput");
          
          if (lastBlockInputRetval)
          {
              retval.replace(ptr(0));
              lastBlockInputRetval = false;
          }
          else
          {
              retval.replace(ptr(1));
              lastBlockInputRetval = true;
          }          
      }
    });

    const NtQueryLicenseValue = Module.getExportByName('ntdll.dll', 'NtQueryLicenseValue');
    Interceptor.attach(NtQueryLicenseValue, {
      onEnter(args) {
          if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
          this.ValueName = args[0].add(4).readPointer().readUtf16String(); //PUNICODE_STRING ValueName
          this.data = args[2];
          //this.dataSize = args[3].readU32();
      },

      onLeave(retval) {
          if ((!appModules.has(this.returnAddress) &&
              onlyAppCode) || 
              retval.toInt32() != 0)
              return;
          if (this.ValueName === "Kernel-VMDetection-Private")
          {
              send("[Others] NtQueryLicenseValue(Kernel-VMDetection-Private)");
              //this.data.writeByteArray(Array(this.dataSize).fill(0x0));
          }
      },
    });

    const GetDriveTypeA = Module.getExportByName('Kernel32.dll', 'GetDriveTypeA');
    Interceptor.attach(GetDriveTypeA, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Others] GetDriveType");
        if (retval.toUInt32() === 2) //DRIVE_REMOVABLE
            retval.replace(ptr(0)); //fake DRIVE_UNKNOWN
      }
    });

    const GetDriveTypeW = Module.getExportByName('Kernel32.dll', 'GetDriveTypeW');
    Interceptor.attach(GetDriveTypeW, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Others] GetDriveType");
        if (retval.toUInt32() === 2) //DRIVE_REMOVABLE
            retval.replace(ptr(0)); //fake DRIVE_UNKNOWN
      }
    });

    try {
        const WNetGetProviderNameA = Module.getExportByName('Mpr.dll', 'WNetGetProviderNameA');
        Interceptor.attach(WNetGetProviderNameA, {
          onEnter(args) {
            this.networkType = args[0].toUInt32(); //DWORD dwNetType
            this.providerName = args[1]; //LPSTR lpProviderName
          },

          onLeave(retval) {
            if ((!appModules.has(this.returnAddress) &&
                onlyAppCode) || 
                retval.toInt32() !== 0)
                return;
            if (this.networkType == 2424832) //WNNC_NET_RDR2SAMPLE
            {
                send("[Others] WNetGetProviderName - replaced provider name: " + this.providerName.readAnsiString());
                this.providerName.writeAnsiString('meow');    
            }
          }
        });

        const WNetGetProviderNameW = Module.getExportByName('Mpr.dll', 'WNetGetProviderNameW');
        Interceptor.attach(WNetGetProviderNameW, {
          onEnter(args) {
            this.networkType = args[0].toUInt32(); //DWORD dwNetType
            this.providerName = args[1]; //LPSTR lpProviderName
          },

          onLeave(retval) {
            if ((!appModules.has(this.returnAddress) &&
                onlyAppCode) || 
                retval.toInt32() !== 0)
                return;
            if (this.networkType == 2424832) //WNNC_NET_RDR2SAMPLE
            {
                send("[Others] WNetGetProviderName - replaced provider name: " + this.providerName.readUtf16String());
                this.providerName.writeUtf16String('meow');    
            }
          }
        });
    } catch (error) {
        console.log(error);
    }

    const OpenProcess = Module.getExportByName('Kernel32.dll', 'OpenProcess');
    Interceptor.attach(OpenProcess, {
      onEnter(args) {
        this.processPid = args[2].toUInt32(); //DWORD dwProcessId
      },  

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && 
            onlyAppCode) || 
            retval.isNull())
            return;
        if (this.processPid === csrssPid)
        {
            send("[Others] OpenProcess - (CSRSS/SeDebugPrivileges)");
            retval.replace(ptr(0)); //fake failure
        }
    }
    });

    const VirtualAlloc = Module.getExportByName('Kernel32.dll', 'VirtualAlloc');
    Interceptor.attach(VirtualAlloc, {
      onEnter(args) {
        this.flAllocationType = args[2].toUInt32(); //DWORD flAllocationType
        this.flProtect = args[3].toUInt32(); //DWORD flProtect
      },  

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) &&
            onlyAppCode) || 
            retval.isNull())
            return;
        if (this.flAllocationType === 2097152) //MEM_WRITE_WATCH (0x00200000)
            IS_MEM_WRITE_WATCH = true;
        if (this.flProtect === 256) //PAGE_GUARD (0x100)
            send("[Others] VirtualAlloc(PAGE_GUARD)");
    }
    });

    const VirtualAllocEx = Module.getExportByName('Kernel32.dll', 'VirtualAllocEx');
    Interceptor.attach(VirtualAllocEx, {
      onEnter(args) {
        this.flAllocationType = args[3].toUInt32(); //DWORD flAllocationType
        this.flProtect = args[4].toUInt32(); //DWORD flProtect
      },  

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) &&
            onlyAppCode) || 
            retval.isNull())
            return;
        if (this.flAllocationType === 2097152) //MEM_WRITE_WATCH (0x00200000)
            IS_MEM_WRITE_WATCH = true;
        if (this.flProtect === 256) //PAGE_GUARD (0x100)
            send("[Others] VirtualAlloc(PAGE_GUARD)");
    }
    });

    const VirtualProtect = Module.getExportByName('Kernel32.dll', 'VirtualProtect');
    Interceptor.attach(VirtualProtect, {
      onEnter(args) {
        this.flNewProtect = args[2].toUInt32(); //DWORD flNewProtect
      },  

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) &&
            onlyAppCode) || 
            retval.toInt32() === 0)
            return;
        if (this.flNewProtect === 256) //PAGE_GUARD (0x100)
            send("[Others] VirtualProtect(PAGE_GUARD)");
    }
    });

    const VirtualProtectEx = Module.getExportByName('Kernel32.dll', 'VirtualProtectEx');
    Interceptor.attach(VirtualProtectEx, {
      onEnter(args) {
        this.flNewProtect = args[3].toUInt32(); //DWORD flNewProtect
      },  

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) &&
            onlyAppCode) || 
            retval.toInt32() === 0)
            return;
        if (this.flNewProtect === 256) //PAGE_GUARD (0x100)
            send("[Others] VirtualProtect(PAGE_GUARD)");
    }
    });

    const GetWriteWatch = Module.getExportByName('Kernel32.dll', 'GetWriteWatch');
    Interceptor.attach(GetWriteWatch, {
      onEnter(args) {
        this.lpBaseAddress = args[1].toInt32(); //PVOID lpBaseAddress
      },  

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) &&
            onlyAppCode) || 
            retval.toUInt32() !== 0)
            return;
        for (let range of Process.enumerateMallocRanges())
            if (this.lpBaseAddress > range.base.toInt32() &&
                this.lpBaseAddress < range.base.toInt32() + range.size &&
                IS_MEM_WRITE_WATCH)
            {
                send("[Others] GetWriteWatch - MEM_WRITE_WATCH memory");
                IS_MEM_WRITE_WATCH = false;
                retval.replace(ptr(1)); //fake failure
            }
    }
    });

    const NtSuspendThread = Module.getExportByName('ntdll.dll', 'NtSuspendThread');
    Interceptor.replace(NtSuspendThread, new NativeCallback((hThread) => {send("[Others] NtSuspendThread");return 1;}, 'int32', ['pointer', 'pointer']));
    const SuspendThread = Module.getExportByName('Kernel32.dll', 'SuspendThread');
    Interceptor.replace(SuspendThread, new NativeCallback((hThread) => {send("[Others] SuspendThread");return 1;}, 'int32', ['pointer']));

    const NtYieldExecution = Module.getExportByName('ntdll.dll', 'NtYieldExecution');
    Interceptor.attach(NtYieldExecution, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Others] NtYieldExecution");
        retval.replace(ptr(0xC0000022)); //return STATUS_ACCESS_DENIED
      },
    });

    const NtSetDebugFilterState = Module.getExportByName('ntdll.dll', 'NtSetDebugFilterState');
    Interceptor.attach(NtSetDebugFilterState, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Others] NtSetDebugFilterState");
        retval.replace(ptr(0xC0000022)); //return STATUS_ACCESS_DENIED
      },
    });

    
    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
