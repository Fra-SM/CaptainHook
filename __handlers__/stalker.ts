/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * detected synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */
    
    //main application module
    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));
    const memfingChecks = false; //causes slow or even frozen execution if enabled
    
    //https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm
    const BeingDebuggedOffset = 0x02;
    const NumberOfProcessorsOffset = Process.pointerSize === 4 ? 0x64 : 0xB8;
    const NtGlobalFlagOffset = Process.pointerSize === 4 ? 0x68 : 0xBC;
    const ProcessHeapOffset = Process.pointerSize === 4 ? 0x18 : 0x30;
    const ProcessHeapFlagsOffset = Process.pointerSize === 4 ? 0x40 : 0x70;
    const ProcessHeapForceFlagsOffset = Process.pointerSize === 4 ? 0x44 : 0x74;

    const KUSER_SHARED_DATA = ptr('0x7FFE0000');
    const KdDebuggerEnabledOffset = 0x2D4;
    const InterruptTimeOffset = 0x8;
    const SystemTimeOffset = 0x14;
    const TickCountQuadOffset = 0x320;

    const addr_RtlGetCurrentPeb = Module.getExportByName('ntdll.dll', 'RtlGetCurrentPeb');
    const fun_RtlGetCurrentPeb = new NativeFunction(addr_RtlGetCurrentPeb, 'pointer', []);

    //Reminder: always use const when passing allocated buffers to NativeFunctions
    const pebAddress = fun_RtlGetCurrentPeb();
    
    //overwrite PEB fields ahead of time (https://anti-debug.checkpoint.com/techniques/debug-flags.html)
    pebAddress.add(BeingDebuggedOffset).writeU8(0); //set BeingDebugged to 0
    pebAddress.add(NumberOfProcessorsOffset).writeUInt(12); //set NumberOfProcessors to 12
    pebAddress.add(NtGlobalFlagOffset).writeUInt(0); //set NtGlobalFlag to 0
    pebAddress.add(ProcessHeapOffset).add(ProcessHeapFlagsOffset).writeUInt(2); //set Flags to HEAP_GROWABLE (0x2)
    pebAddress.add(ProcessHeapOffset).add(ProcessHeapForceFlagsOffset).writeUInt(0); //set ForceFlags to 0

    //let threadIds = [];
    let threads = Process.enumerateThreads();

    function onCpuid (context) {
        if (Process.pointerSize === 4)
        {
            if (context.eax.toInt32() === 1)
            {
                //set 31st bit of ecx to 0
                let mask = ~(1 << 31);
                context.ecx = ptr(mask & context.ecx.toInt32());
                send("[CPU Fingerprinting] CPUID(EAX=0x1)");
            }
                
            if (context.eax.toInt32() === 1073741824)
            {
                //set the returned content to 0
                context.ebx = ptr(0);
                context.ecx = ptr(0);
                context.edx = ptr(0);
                send("[CPU Fingerprinting] CPUID(EAX=0x40000000)");
            }
        }
        else
        {
            if (context.rax.toInt32() === 1)
            {
                //set 31st bit of ecx to 0
                let mask = ~(1 << 31);
                context.rcx = ptr(mask & context.rcx.toInt32());
                send("[CPU Fingerprinting] CPUID(RAX=0x1)");
            }
                
            if (context.rax.toInt32() === 1073741824)
            {
                //set the returned content to 0
                context.rbx = ptr(0);
                context.rcx = ptr(0);
                context.rdx = ptr(0);
                send("[CPU Fingerprinting] CPUID(RAX=0x40000000)");
            }
        }
    }

    function onVpcext(context) {
        //set ebx/rbx to a value different than 0 to avoid VM detection
        if (Process.pointerSize === 4)
            context.ebx = ptr(1);
        else
            context.rbx = ptr(1);
    }

    function checkMemoryFingerprintingTechniques (context) {
        var curInstruction = Instruction.parse(context.pc);
        var value = '';
        
        for (let op of curInstruction.operands)
        {
            if (op.type === 'reg')
                value = context[op.value] !== undefined ? context[op.value].toString().replace("0x", "") : '';                    
            else if (op.type === 'imm')
                value = op.value.toString(16);
            
            switch (value) {
                case KUSER_SHARED_DATA.add(KdDebuggerEnabledOffset).toString(16):
                    send("[Memory Fingerprinting] KUSER_SHARED_DATA->KdDebuggerEnabled");
                    break;
                case KUSER_SHARED_DATA.add(InterruptTimeOffset).toString(16):
                    send("[Timing] KUSER_SHARED_DATA->InterruptTime");
                    break;
                case KUSER_SHARED_DATA.add(SystemTimeOffset).toString(16):
                    send("[Timing] KUSER_SHARED_DATA->SystemTime");
                    break;
                case KUSER_SHARED_DATA.add(TickCountQuadOffset).toString(16):
                    send("[Timing] KUSER_SHARED_DATA->TickCountQuad");
                    break;
                case pebAddress.add(BeingDebuggedOffset).toString(16):
                    send("[Memory Fingerprinting] PEB->BeingDebugged");
                    break;
                case pebAddress.add(NtGlobalFlagOffset).toString(16):
                    send("[Memory Fingerprinting] PEB->NtGlobalFlag");
                    break;
                case pebAddress.add(ProcessHeapOffset).add(ProcessHeapFlagsOffset).toString(16):
                    send("[Memory Fingerprinting] PEB->ProcessHeap->Flags");
                    break;
                case pebAddress.add(ProcessHeapOffset).add(ProcessHeapForceFlagsOffset).toString(16):
                    send("[Memory Fingerprinting] PEB->ProcessHeap->ForceFlags");
                    break;
                case pebAddress.add(NumberOfProcessorsOffset).toString(16):
                    send("[System Environment] PEB->NumberOfProcessors");
                    break;
                default:
                    break;
            }
        }         
    }

    /* function wmiExec (context) {
        Memory.protect(context.r10, Process.pageSize, 'rwx');
        //this prints test.exe!CWbemObject::GetUnmarshalClass
        console.log(DebugSymbol.fromAddress(context.r10)); //this should be the location of ExecQuery inside the test.exe binary, but it's not
        //console.log(hexdump(context.r10));
    } */

	for (let thread of threads)
    {
        //threadIds.push(thread.id);
        //console.log(thread.id);

        //consider writing a "CModule" instead to improve performance
        Stalker.follow(thread.id, {
            events: {
                exec: false, //trace every instruction
                block: false,
                compile: true
            },  

            transform(iterator) {
                let instruction = iterator.next();
                let isAppCode = appModules.has(instruction.address);
                //console.log(instruction.toString());
                
                do {
                if (isAppCode)
                {
                    let opcode = new Uint8Array(instruction.address.readByteArray(1))[0];
                    
                    //super slow execution if enabled
                    if (instruction.mnemonic.includes('mov') && memfingChecks)
                        iterator.putCallout(checkMemoryFingerprintingTechniques);
                    if (instruction.mnemonic === "sidt")
                    {
                        //console.log(instruction.toString());
                        send("[Table Descriptors] SIDT");
                    }
                    if (instruction.mnemonic === "sgdt")
                    {
                        //console.log(instruction.toString());
                        send("[Table Descriptors] SGDT");
                    }
                    if (instruction.mnemonic === "sldt")
                    {
                        //console.log(instruction.toString());
                        send("[Table Descriptors] SLDT");
                    }
                    if (instruction.mnemonic === "cpuid")
                    {
                        //console.log(instruction.toString());
                        iterator.putCallout(onCpuid);
                    }
                    if (instruction.mnemonic === "in")
                    {
                        //console.log(instruction.toString());
                        send("[CPU Fingerprinting] IN");
                        //continue; //drops the instruction
                    }
                    if (instruction.mnemonic === "str")
                    {
                        //console.log(instruction.toString());
                        send("[CPU Fingerprinting] STR");
                    }
                    if (instruction.mnemonic === "smsw")
                    {
                        //console.log(instruction.toString());
                        send("[CPU Fingerprinting] SMSW");
                    }
                    //TODO: idea for the traps instruction, check the current thread backtrace to see if an exception handler was registered before
                    //check for opcode "0xcc" (204) (alternative: if (instruction.toString().includes("int3")))
                    if (opcode === 204 && instruction.size === 1)
                    {
                        console.log(instruction.toString());
                        send("[Traps] INT3");
                        //continue; //drops the instruction
                    }
                    if (instruction.toString().includes("int 0x2d"))
                    {
                        console.log(instruction.toString());
                        send("[Traps] INT2D");
                        //continue; //drops the instruction
                    }
                    if (instruction.toString().includes("int 1") || instruction.toString().includes("int1"))
                    {
                        console.log(instruction.toString());
                        send("[Traps] INT1");
                        //continue; //drops the instruction
                    }
                    //check for opcode "0xf1" (241)
                    if (opcode === 241 && instruction.size === 1)
                    {
                        console.log(instruction.toString());
                        send("[Traps] ICEBP");
                        //continue; //drops the instruction
                    }
                    if (instruction.mnemonic === "vpcext")
                    {
                        //console.log(instruction.toString());
                        iterator.putCallout(onVpcext);
                        send("[Traps] VPCEXT");
                    }
                    //invalid on x64
                    if (instruction.toString().includes("pop ss"))
                    {
                        console.log(instruction.toString());
                        send("[Traps] POP SS");
                        //continue; //drops the instruction
                    }
                    if (instruction.toString().includes("popf"))
                    {
                        //console.log(instruction.toString());
                        send("[Traps] POPF");
                        //continue;
                    }
                    if (instruction.mnemonic.includes("rdtsc"))
                    {
                        //console.log(instruction.toString());
                        send("[Timing] RDTSC");
                    }
                    /* if (instruction.toString().includes("fs"))
                    {
                        iterator.putCallout(checkMemoryFingerprintingTechniques);
                        console.log(JSON.stringify(instruction.operands));
                    } */

                    //this was a test to get the address of ExecQuery
                    /* if (instruction.address.equals(Process.enumerateModules()[0].base.add('0x352c'))) //offset from Ghidra
                        iterator.putCallout(wmiExec); */
                }

                    iterator.keep(); //necessary, otherwise instructions get dropped
                }
                while ((instruction = iterator.next()) !== null);
            }
        });
    }

    /**
     * detected synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
  