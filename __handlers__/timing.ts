/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */
    
    interface SYSTEMTIME {
        wYear: number;
        wMonth: number;
        wDayOfWeek: number;
        wDay: number;
        wHour: number;
        wMinute: number;
        wSecond: number;
        wMilliseconds: number;
    }

    interface FILETIME {
        dwLowDateTime: number;
        dwHighDateTime: number;
    }

    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));

    let LAST_GETTICKCOUNT_UPTIME = 33840000; //9.4 hours uptime
    let GETTICKCOUNT_DELTA = 10;

    let LAST_NTGETTICKCOUNT_UPTIME = 33840000; //9.4 hours uptime
    let NTGETTICKCOUNT_DELTA = 10;

    let LAST_TIMEGETTIME_UPTIME = 33840000; //9.4 hours uptime
    let TIMEGETTIME_DELTA = 10;

    let LAST_TIMEGETSYSTEMTIME_UPTIME = 33840000; //9.4 hours uptime
    let TIMEGETSYSTEMTIME_DELTA = 10;

    let LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = 33840000 * 1e4; //9.4 hours uptime in units of 100 ns
    let QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS = 10 * 1e4;

    let LAST_PERFORMANCE_COUNTER = 0;
    let PERFORMANCE_COUNTER_DELTA = 1;

    let GETSYSTEMTIME_CALLED_ONCE = false;
    let LAST_SYSTEMTIME: SYSTEMTIME;
    let GETSYSTEMTIME_DELTA = 10;

    let GETLOCALTIME_CALLED_ONCE = false;
    let LAST_LOCALTIME: SYSTEMTIME;
    let GETLOCALTIME_DELTA = 10;

    let GETSYSTEMTIMEASFILETIME_CALLED_ONCE = false;
    let LAST_SYSTEMTIMEASFILETIME: FILETIME;
    let GETSYSTEMTIMEASFILETIME_DELTA = 100;

    const GetTickCount = Module.getExportByName('Kernel32.dll', 'GetTickCount');
    Interceptor.attach(GetTickCount, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Timing] GetTickCount - original uptime: " + retval.toUInt32());
        retval.replace(ptr(LAST_GETTICKCOUNT_UPTIME)); 
        LAST_GETTICKCOUNT_UPTIME = LAST_GETTICKCOUNT_UPTIME + GETTICKCOUNT_DELTA;
      }
    });

    const GetTickCount64 = Module.getExportByName('Kernel32.dll', 'GetTickCount64');
    Interceptor.attach(GetTickCount64, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Timing] GetTickCount64 - original uptime: " + retval);
        retval.replace(ptr(LAST_GETTICKCOUNT_UPTIME)); 
        LAST_GETTICKCOUNT_UPTIME = LAST_GETTICKCOUNT_UPTIME + GETTICKCOUNT_DELTA;
      }
    });

    const NtGetTickCount = Module.getExportByName('ntdll.dll', 'NtGetTickCount');
    Interceptor.attach(NtGetTickCount, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Timing] NtGetTickCount - original uptime: " + retval);
        retval.replace(ptr(LAST_NTGETTICKCOUNT_UPTIME)); 
        LAST_NTGETTICKCOUNT_UPTIME = LAST_NTGETTICKCOUNT_UPTIME + NTGETTICKCOUNT_DELTA;
      }
    });

    const timeGetTime = Module.getExportByName('Winmm.dll', 'timeGetTime');
    Interceptor.attach(timeGetTime, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Timing] timeGetTime - original uptime: " + retval.toUInt32());
        retval.replace(ptr(LAST_TIMEGETTIME_UPTIME)); 
        LAST_TIMEGETTIME_UPTIME = LAST_TIMEGETTIME_UPTIME + TIMEGETTIME_DELTA;
      }
    });

    const timeGetSystemTime = Module.getExportByName('Winmm.dll', 'timeGetSystemTime');
    Interceptor.attach(timeGetSystemTime, {
      onEnter(args) {
        this.pmmt = args[0]; //LPMMTIME pmmt
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Timing] timeGetSystemTime - original uptime: " + this.pmmt.add(4).readUInt()); //DWORD ms
        this.pmmt.add(4).writeUInt(LAST_TIMEGETSYSTEMTIME_UPTIME); 
        LAST_TIMEGETSYSTEMTIME_UPTIME = LAST_TIMEGETSYSTEMTIME_UPTIME + TIMEGETSYSTEMTIME_DELTA;
      }
    });

    const QueryUnbiasedInterruptTime = Module.getExportByName('Kernel32.dll', 'QueryUnbiasedInterruptTime');
    Interceptor.attach(QueryUnbiasedInterruptTime, {
      onEnter(args) {
        this.UnbiasedTime = args[0]; //PULONGLONG UnbiasedTime
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) || retval.toInt32() === 0)
            return;
        send("[Timing] QueryUnbiasedInterruptTime - original time: " + this.UnbiasedTime.readULong());
        this.UnbiasedTime.writeULong(LAST_QUERYINTERRUPTTIME_ALL_VARIANTS);
        LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = LAST_QUERYINTERRUPTTIME_ALL_VARIANTS + QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS;
      }
    });

    //the following 3 functions are available only on Win10+
    const QueryInterruptTime = Module.getExportByName('Kernel32.dll', 'QueryInterruptTime');
    Interceptor.attach(QueryInterruptTime, {
      onEnter(args) {
        this.lpInterruptTime = args[0]; //PULONGLONG lpInterruptTime
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Timing] QueryInterruptTime - original time: " + this.lpInterruptTime.readULong());
        this.lpInterruptTime.writeULong(LAST_QUERYINTERRUPTTIME_ALL_VARIANTS);
        LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = LAST_QUERYINTERRUPTTIME_ALL_VARIANTS + QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS;
      }
    });

    const QueryInterruptTimePrecise = Module.getExportByName('Kernel32.dll', 'QueryInterruptTimePrecise');
    Interceptor.attach(QueryInterruptTimePrecise, {
      onEnter(args) {
        this.lpInterruptTimePrecise = args[0]; //PULONGLONG lpInterruptTimePrecise
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Timing] QueryInterruptTimePrecise - original time: " + this.lpInterruptTimePrecise.readULong());
        this.lpInterruptTimePrecise.writeULong(LAST_QUERYINTERRUPTTIME_ALL_VARIANTS);
        LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = LAST_QUERYINTERRUPTTIME_ALL_VARIANTS + QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS;
      }
    });

    const QueryUnbiasedInterruptTimePrecise = Module.getExportByName('Kernel32.dll', 'QueryUnbiasedInterruptTimePrecise');
    Interceptor.attach(QueryUnbiasedInterruptTimePrecise, {
      onEnter(args) {
        this.lpUnbiasedInterruptTimePrecise = args[0]; //PULONGLONG lpUnbiasedInterruptTimePrecise
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[Timing] QueryUnbiasedInterruptTimePrecise - original time: " + this.lpUnbiasedInterruptTimePrecise.readULong());
        this.lpUnbiasedInterruptTimePrecise.writeULong(LAST_QUERYINTERRUPTTIME_ALL_VARIANTS);
        LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = LAST_QUERYINTERRUPTTIME_ALL_VARIANTS + QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS;
      }
    });

    const QueryPerformanceCounter = Module.getExportByName('Kernel32.dll', 'QueryPerformanceCounter');
    Interceptor.attach(QueryPerformanceCounter, {
      onEnter(args) {
        this.lpPerformanceCount = args[0]; //LARGE_INTEGER *lpPerformanceCount
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) || retval.toInt32() === 0)
            return;
        var divided_time = this.lpPerformanceCount.readLong();
        send("[Timing] QueryPerformanceCounter - original counter: " + divided_time);
        if (LAST_PERFORMANCE_COUNTER != 0)
            divided_time = LAST_PERFORMANCE_COUNTER + PERFORMANCE_COUNTER_DELTA;
        this.lpPerformanceCount.writeLong(divided_time);
        LAST_PERFORMANCE_COUNTER = divided_time;
      }
    });

    const NtQueryPerformanceCounter = Module.getExportByName('ntdll.dll', 'NtQueryPerformanceCounter');
    Interceptor.attach(NtQueryPerformanceCounter, {
      onEnter(args) {
        this.PerformanceCounter = args[0]; //PLARGE_INTEGER PerformanceCounter
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) || retval.toInt32() !== 0)
            return;
        var divided_time = this.PerformanceCounter.readLong();
        send("[Timing] NtQueryPerformanceCounter - original counter: " + divided_time);
        if (LAST_PERFORMANCE_COUNTER != 0)
            divided_time = LAST_PERFORMANCE_COUNTER + PERFORMANCE_COUNTER_DELTA;
        this.PerformanceCounter.writeLong(divided_time);
        LAST_PERFORMANCE_COUNTER = divided_time;
      }
    });

    /* typedef struct _SYSTEMTIME {
        WORD wYear;
        WORD wMonth;
        WORD wDayOfWeek;
        WORD wDay;
        WORD wHour;
        WORD wMinute;
        WORD wSecond;
        WORD wMilliseconds;
      } SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME; */
    const GetSystemTime = Module.getExportByName('Kernel32.dll', 'GetSystemTime');
    Interceptor.attach(GetSystemTime, {
      onEnter(args) {
        this.lpSystemTime = args[0]; //LPSYSTEMTIME lpSystemTime
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) || this.lpSystemTime.isNull())
            return;
        if (GETSYSTEMTIME_CALLED_ONCE)
        {
            GETSYSTEMTIME_CALLED_ONCE = true;
            LAST_SYSTEMTIME.wYear = this.lpSystemTime.readUShort();
            LAST_SYSTEMTIME.wMonth = this.lpSystemTime.add(2).readUShort();
            LAST_SYSTEMTIME.wDayOfWeek = this.lpSystemTime.add(4).readUShort();
            LAST_SYSTEMTIME.wDay = this.lpSystemTime.add(6).readUShort();
            LAST_SYSTEMTIME.wHour = this.lpSystemTime.add(8).readUShort();
            LAST_SYSTEMTIME.wMinute = this.lpSystemTime.add(10).readUShort();
            LAST_SYSTEMTIME.wSecond = this.lpSystemTime.add(12).readUShort();
            LAST_SYSTEMTIME.wMilliseconds = this.lpSystemTime.add(14).readUShort();
        }
        else
        {
            this.lpSystemTime.writeUShort(LAST_SYSTEMTIME.wYear);
            this.lpSystemTime.add(2).writeUShort(LAST_SYSTEMTIME.wMonth);
            this.lpSystemTime.add(4).writeUShort(LAST_SYSTEMTIME.wDayOfWeek);
            this.lpSystemTime.add(6).writeUShort(LAST_SYSTEMTIME.wDay);
            this.lpSystemTime.add(8).writeUShort(LAST_SYSTEMTIME.wHour);
            this.lpSystemTime.add(10).writeUShort(LAST_SYSTEMTIME.wMinute);
            this.lpSystemTime.add(12).writeUShort(LAST_SYSTEMTIME.wSecond);
            this.lpSystemTime.add(14).writeUShort(LAST_SYSTEMTIME.wMilliseconds + GETSYSTEMTIME_DELTA);
        }
        
        send("[Timing] GetSystemTime");
      }
    });

    const GetLocalTime = Module.getExportByName('Kernel32.dll', 'GetLocalTime');
    Interceptor.attach(GetLocalTime, {
      onEnter(args) {
        this.lpSystemTime = args[0]; //LPSYSTEMTIME lpSystemTime
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) || this.lpSystemTime.isNull())
            return;
        if (GETLOCALTIME_CALLED_ONCE)
        {
            GETLOCALTIME_CALLED_ONCE = true;
            LAST_LOCALTIME.wYear = this.lpSystemTime.readUShort();
            LAST_LOCALTIME.wMonth = this.lpSystemTime.add(2).readUShort();
            LAST_LOCALTIME.wDayOfWeek = this.lpSystemTime.add(4).readUShort();
            LAST_LOCALTIME.wDay = this.lpSystemTime.add(6).readUShort();
            LAST_LOCALTIME.wHour = this.lpSystemTime.add(8).readUShort();
            LAST_LOCALTIME.wMinute = this.lpSystemTime.add(10).readUShort();
            LAST_LOCALTIME.wSecond = this.lpSystemTime.add(12).readUShort();
            LAST_LOCALTIME.wMilliseconds = this.lpSystemTime.add(14).readUShort();
        }
        else
        {
            this.lpSystemTime.writeUShort(LAST_LOCALTIME.wYear);
            this.lpSystemTime.add(2).writeUShort(LAST_LOCALTIME.wMonth);
            this.lpSystemTime.add(4).writeUShort(LAST_LOCALTIME.wDayOfWeek);
            this.lpSystemTime.add(6).writeUShort(LAST_LOCALTIME.wDay);
            this.lpSystemTime.add(8).writeUShort(LAST_LOCALTIME.wHour);
            this.lpSystemTime.add(10).writeUShort(LAST_LOCALTIME.wMinute);
            this.lpSystemTime.add(12).writeUShort(LAST_LOCALTIME.wSecond);
            this.lpSystemTime.add(14).writeUShort(LAST_LOCALTIME.wMilliseconds + GETLOCALTIME_DELTA);
        }
        
        send("[Timing] GetLocalTime");
      }
    });

    /* typedef struct _FILETIME {
        DWORD dwLowDateTime;
        DWORD dwHighDateTime;
      } FILETIME, *PFILETIME, *LPFILETIME; */
    const GetSystemTimeAsFiletime = Module.getExportByName('Kernel32.dll', 'GetSystemTimeAsFiletime');
    Interceptor.attach(GetSystemTimeAsFiletime, {
    onEnter(args) {
        this.lpSystemTimeAsFileTime = args[0]; //LPFILETIME lpSystemTimeAsFileTime
    },

    onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        if (GETSYSTEMTIMEASFILETIME_CALLED_ONCE)
        {
            GETSYSTEMTIMEASFILETIME_CALLED_ONCE = true;
            LAST_SYSTEMTIMEASFILETIME.dwLowDateTime = this.lpSystemTimeAsFileTime.readUInt();
            LAST_SYSTEMTIMEASFILETIME.dwHighDateTime = this.lpSystemTimeAsFileTime.add(4).readUInt();
        }
        else
        {
            this.lpSystemTimeAsFileTime.writeUInt(LAST_SYSTEMTIMEASFILETIME.dwLowDateTime + GETSYSTEMTIMEASFILETIME_DELTA);
            this.lpSystemTimeAsFileTime.add(4).writeUInt(LAST_SYSTEMTIMEASFILETIME.dwHighDateTime);
        }
        
        send("[Timing] GetSystemTimeAsFiletime");
    }
    });
    
    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
