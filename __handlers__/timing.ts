/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */
    
    let wYearST;
    let wMonthST;
    let wDayOfWeekST;
    let wDayST;
    let wHourST;
    let wMinuteST;
    let wSecondST;
    let wMillisecondsST;

    let wYearLT;
    let wMonthLT;
    let wDayOfWeekLT;
    let wDayLT;
    let wHourLT;
    let wMinuteLT;
    let wSecondLT;
    let wMillisecondsLT;

    let lastdwLowDateTime;
    let lastdwHighDateTime;

    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));
    const onlyAppCode = true;

    let LAST_GETTICKCOUNT_UPTIME = 33840000; //9.4 hours uptime
    let GETTICKCOUNT_DELTA = 10;

    let LAST_NTGETTICKCOUNT_UPTIME = 33840000; //9.4 hours uptime
    let NTGETTICKCOUNT_DELTA = 10;

    let LAST_TIMEGETTIME_UPTIME = 33840000; //9.4 hours uptime
    let TIMEGETTIME_DELTA = 10;

    let LAST_TIMEGETSYSTEMTIME_UPTIME = 33840000; //9.4 hours uptime
    let TIMEGETSYSTEMTIME_DELTA = 10;

    let LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = 33840000 * 1e4; //9.4 hours uptime in units of 100 ns
    let QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS = 10 * 1e4;

    let LAST_PERFORMANCE_COUNTER = 0;
    let PERFORMANCE_COUNTER_DELTA = 1;

    let GETSYSTEMTIME_CALLED_ONCE = false;
    let GETSYSTEMTIME_DELTA = 10;

    let GETLOCALTIME_CALLED_ONCE = false;
    let GETLOCALTIME_DELTA = 10;

    let GETSYSTEMTIMEASFILETIME_CALLED_ONCE = false;
    let GETSYSTEMTIMEASFILETIME_DELTA = 100;

    const GetTickCount = Module.getExportByName('Kernel32.dll', 'GetTickCount');
    Interceptor.attach(GetTickCount, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Timing] GetTickCount - original uptime: " + retval.toUInt32());
        retval.replace(ptr(LAST_GETTICKCOUNT_UPTIME)); 
        LAST_GETTICKCOUNT_UPTIME = LAST_GETTICKCOUNT_UPTIME + GETTICKCOUNT_DELTA;
      }
    });

    const GetTickCount64 = Module.getExportByName('Kernel32.dll', 'GetTickCount64');
    Interceptor.attach(GetTickCount64, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Timing] GetTickCount64 - original uptime: " + retval);
        retval.replace(ptr(LAST_GETTICKCOUNT_UPTIME)); 
        LAST_GETTICKCOUNT_UPTIME = LAST_GETTICKCOUNT_UPTIME + GETTICKCOUNT_DELTA;
      }
    });

    const NtGetTickCount = Module.getExportByName('ntdll.dll', 'NtGetTickCount');
    Interceptor.attach(NtGetTickCount, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Timing] NtGetTickCount - original uptime: " + retval);
        retval.replace(ptr(LAST_NTGETTICKCOUNT_UPTIME)); 
        LAST_NTGETTICKCOUNT_UPTIME = LAST_NTGETTICKCOUNT_UPTIME + NTGETTICKCOUNT_DELTA;
      }
    });

    const timeGetTime = Module.getExportByName('Winmm.dll', 'timeGetTime');
    Interceptor.attach(timeGetTime, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Timing] timeGetTime - original uptime: " + retval.toUInt32());
        retval.replace(ptr(LAST_TIMEGETTIME_UPTIME)); 
        LAST_TIMEGETTIME_UPTIME = LAST_TIMEGETTIME_UPTIME + TIMEGETTIME_DELTA;
      }
    });

    const timeGetSystemTime = Module.getExportByName('Winmm.dll', 'timeGetSystemTime');
    Interceptor.attach(timeGetSystemTime, {
      onEnter(args) {
        this.pmmt = args[0]; //LPMMTIME pmmt
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[Timing] timeGetSystemTime - original uptime: " + this.pmmt.add(4).readUInt()); //DWORD ms
        this.pmmt.add(4).writeUInt(LAST_TIMEGETSYSTEMTIME_UPTIME); 
        LAST_TIMEGETSYSTEMTIME_UPTIME = LAST_TIMEGETSYSTEMTIME_UPTIME + TIMEGETSYSTEMTIME_DELTA;
      }
    });

    const QueryUnbiasedInterruptTime = Module.getExportByName('Kernel32.dll', 'QueryUnbiasedInterruptTime');
    Interceptor.attach(QueryUnbiasedInterruptTime, {
      onEnter(args) {
        this.UnbiasedTime = args[0]; //PULONGLONG UnbiasedTime
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) || 
            retval.toInt32() === 0)
            return;
        send("[Timing] QueryUnbiasedInterruptTime - original time: " + this.UnbiasedTime.readULong());
        this.UnbiasedTime.writeULong(LAST_QUERYINTERRUPTTIME_ALL_VARIANTS);
        LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = LAST_QUERYINTERRUPTTIME_ALL_VARIANTS + QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS;
      }
    });

    
    try {
      //the following 3 functions are available only on Win10+
      const QueryInterruptTime = Module.getExportByName('Kernel32.dll', 'QueryInterruptTime');
      Interceptor.attach(QueryInterruptTime, {
        onEnter(args) {
          this.lpInterruptTime = args[0]; //PULONGLONG lpInterruptTime
        },
  
        onLeave() {
          if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
          send("[Timing] QueryInterruptTime - original time: " + this.lpInterruptTime.readULong());
          this.lpInterruptTime.writeULong(LAST_QUERYINTERRUPTTIME_ALL_VARIANTS);
          LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = LAST_QUERYINTERRUPTTIME_ALL_VARIANTS + QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS;
        }
      });
  
      const QueryInterruptTimePrecise = Module.getExportByName('Kernel32.dll', 'QueryInterruptTimePrecise');
      Interceptor.attach(QueryInterruptTimePrecise, {
        onEnter(args) {
          this.lpInterruptTimePrecise = args[0]; //PULONGLONG lpInterruptTimePrecise
        },
  
        onLeave() {
          if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
          send("[Timing] QueryInterruptTimePrecise - original time: " + this.lpInterruptTimePrecise.readULong());
          this.lpInterruptTimePrecise.writeULong(LAST_QUERYINTERRUPTTIME_ALL_VARIANTS);
          LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = LAST_QUERYINTERRUPTTIME_ALL_VARIANTS + QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS;
        }
      });
  
      const QueryUnbiasedInterruptTimePrecise = Module.getExportByName('Kernel32.dll', 'QueryUnbiasedInterruptTimePrecise');
      Interceptor.attach(QueryUnbiasedInterruptTimePrecise, {
        onEnter(args) {
          this.lpUnbiasedInterruptTimePrecise = args[0]; //PULONGLONG lpUnbiasedInterruptTimePrecise
        },
  
        onLeave() {
          if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
          send("[Timing] QueryUnbiasedInterruptTimePrecise - original time: " + this.lpUnbiasedInterruptTimePrecise.readULong());
          this.lpUnbiasedInterruptTimePrecise.writeULong(LAST_QUERYINTERRUPTTIME_ALL_VARIANTS);
          LAST_QUERYINTERRUPTTIME_ALL_VARIANTS = LAST_QUERYINTERRUPTTIME_ALL_VARIANTS + QUERYINTERRUPTTIME_DELTA_ALL_VARIANTS;
        }
      });
    } catch (error) {
        console.log(error);
    }

    const QueryPerformanceCounter = Module.getExportByName('Kernel32.dll', 'QueryPerformanceCounter');
    Interceptor.attach(QueryPerformanceCounter, {
      onEnter(args) {
        this.lpPerformanceCount = args[0]; //LARGE_INTEGER *lpPerformanceCount
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) || 
            retval.toInt32() === 0)
            return;
        var divided_time = this.lpPerformanceCount.readLong();
        send("[Timing] QueryPerformanceCounter - original counter: " + divided_time);
        if (LAST_PERFORMANCE_COUNTER != 0)
            divided_time = LAST_PERFORMANCE_COUNTER + PERFORMANCE_COUNTER_DELTA;
        this.lpPerformanceCount.writeLong(divided_time);
        LAST_PERFORMANCE_COUNTER = divided_time;
      }
    });

    const NtQueryPerformanceCounter = Module.getExportByName('ntdll.dll', 'NtQueryPerformanceCounter');
    Interceptor.attach(NtQueryPerformanceCounter, {
      onEnter(args) {
        this.PerformanceCounter = args[0]; //PLARGE_INTEGER PerformanceCounter
      },

      onLeave(retval) {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) || 
            retval.toInt32() !== 0)
            return;
        var divided_time = this.PerformanceCounter.readLong();
        send("[Timing] NtQueryPerformanceCounter - original counter: " + divided_time);
        if (LAST_PERFORMANCE_COUNTER != 0)
            divided_time = LAST_PERFORMANCE_COUNTER + PERFORMANCE_COUNTER_DELTA;
        this.PerformanceCounter.writeLong(divided_time);
        LAST_PERFORMANCE_COUNTER = divided_time;
      }
    });

    /* typedef struct _SYSTEMTIME {
        WORD wYear;
        WORD wMonth;
        WORD wDayOfWeek;
        WORD wDay;
        WORD wHour;
        WORD wMinute;
        WORD wSecond;
        WORD wMilliseconds;
      } SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME; */
    const GetSystemTime = Module.getExportByName('Kernel32.dll', 'GetSystemTime');
    Interceptor.attach(GetSystemTime, {
      onEnter(args) {
        this.lpSystemTime = args[0]; //LPSYSTEMTIME lpSystemTime
      },

      onLeave() {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            this.lpSystemTime.isNull())
            return;
        if (!GETSYSTEMTIME_CALLED_ONCE)
        {
            GETSYSTEMTIME_CALLED_ONCE = true;
            wYearST = this.lpSystemTime.readUShort();
            wMonthST = this.lpSystemTime.add(2).readUShort();
            wDayOfWeekST = this.lpSystemTime.add(4).readUShort();
            wDayST = this.lpSystemTime.add(6).readUShort();
            wHourST= this.lpSystemTime.add(8).readUShort();
            wMinuteST = this.lpSystemTime.add(10).readUShort();
            wSecondST = this.lpSystemTime.add(12).readUShort();
            wMillisecondsST = this.lpSystemTime.add(14).readUShort();
        }
        else
        {
            this.lpSystemTime.writeUShort(wYearST);
            this.lpSystemTime.add(2).writeUShort(wMonthST);
            this.lpSystemTime.add(4).writeUShort(wDayOfWeekST);
            this.lpSystemTime.add(6).writeUShort(wDayST);
            this.lpSystemTime.add(8).writeUShort(wHourST);
            this.lpSystemTime.add(10).writeUShort(wMinuteST);
            this.lpSystemTime.add(12).writeUShort(wSecondST);
            this.lpSystemTime.add(14).writeUShort(wMillisecondsST + GETSYSTEMTIME_DELTA);
        }
        
        send("[Timing] GetSystemTime");
      }
    });

    const GetLocalTime = Module.getExportByName('Kernel32.dll', 'GetLocalTime');
    Interceptor.attach(GetLocalTime, {
      onEnter(args) {
        this.lpSystemTime = args[0]; //LPSYSTEMTIME lpSystemTime
      },

      onLeave() {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            this.lpSystemTime.isNull())
            return;
        if (!GETLOCALTIME_CALLED_ONCE)
        {
            GETLOCALTIME_CALLED_ONCE = true;
            wYearLT = this.lpSystemTime.readUShort();
            wMonthLT = this.lpSystemTime.add(2).readUShort();
            wDayOfWeekLT = this.lpSystemTime.add(4).readUShort();
            wDayLT = this.lpSystemTime.add(6).readUShort();
            wHourLT = this.lpSystemTime.add(8).readUShort();
            wMinuteLT = this.lpSystemTime.add(10).readUShort();
            wSecondLT = this.lpSystemTime.add(12).readUShort();
            wMillisecondsLT = this.lpSystemTime.add(14).readUShort();
        }
        else
        {
            this.lpSystemTime.writeUShort(wYearLT);
            this.lpSystemTime.add(2).writeUShort(wMonthLT);
            this.lpSystemTime.add(4).writeUShort(wDayOfWeekLT);
            this.lpSystemTime.add(6).writeUShort(wDayLT);
            this.lpSystemTime.add(8).writeUShort(wHourLT);
            this.lpSystemTime.add(10).writeUShort(wMinuteLT);
            this.lpSystemTime.add(12).writeUShort(wSecondLT);
            this.lpSystemTime.add(14).writeUShort(wMillisecondsLT + GETLOCALTIME_DELTA);
        }
        
        send("[Timing] GetLocalTime");
      }
    });

    /* typedef struct _FILETIME {
        DWORD dwLowDateTime;
        DWORD dwHighDateTime;
      } FILETIME, *PFILETIME, *LPFILETIME; */
    const GetSystemTimeAsFileTime = Module.getExportByName('Kernel32.dll', 'GetSystemTimeAsFileTime');
    Interceptor.attach(GetSystemTimeAsFileTime, {
    onEnter(args) {
        this.lpSystemTimeAsFileTime = args[0]; //LPFILETIME lpSystemTimeAsFileTime
    },

    onLeave() {
        if ((!appModules.has(this.returnAddress) && onlyAppCode) ||
            this.lpSystemTimeAsFileTime.isNull())
            return;
        if (!GETSYSTEMTIMEASFILETIME_CALLED_ONCE)
        {
            GETSYSTEMTIMEASFILETIME_CALLED_ONCE = true;
            lastdwLowDateTime = this.lpSystemTimeAsFileTime.readUInt();
            lastdwHighDateTime = this.lpSystemTimeAsFileTime.add(4).readUInt();
        }
        else
        {
            this.lpSystemTimeAsFileTime.writeUInt(lastdwLowDateTime + GETSYSTEMTIMEASFILETIME_DELTA);
            //this.lpSystemTimeAsFileTime.add(4).writeUInt(lastdwHighDateTime);
        }
        
        send("[Timing] GetSystemTimeAsFileTime");
    }
    });
    
    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
