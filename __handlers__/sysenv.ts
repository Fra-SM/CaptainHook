/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */

    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));
    const onlyAppCode = true;

    let windows_blacklist = [
                         "vbox",
                         "virtualbox",
                         "virtual box",
                         "vmware",
                         "immunity", 
                         "ollydbg", 
                         "windbg", 
                         "x64dbg", 
                         "x32dbg", 
                         "ghidra", 
                         "ida",
                         "wireshark",
                         "procmon",
                         "filemon",
                         "regmon",
                         "netmon",
                         "processhacker",
                         "process monitor",
                         "fiddler",
                         "apimonitor",
                         "api monitor",
                         "scylla",
                         "debug",
                         "peid",
                         "die",
                         "procdump",
                         "sandbox",
                         "gbdyllo",
                         "pediy06",
                         "zeta debugger",
                         "rock debugger",
                         "obsidian",
                         "sunawtframe",
                         "qt5qwindowicon",
                         "antidbg"
                        ]

    //useful reference for data types sizes: https://learn.microsoft.com/it-it/windows/win32/winprog/windows-data-types
    const IsDebuggerPresent = Module.getExportByName('Kernel32.dll', 'IsDebuggerPresent');
    Interceptor.attach(IsDebuggerPresent, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        retval.replace(ptr(0)); //return FALSE
        send("[System Environment] IsDebuggerPresent");
      }
    });

    const CheckRemoteDebuggerPresent = Module.getExportByName('Kernel32.dll', 'CheckRemoteDebuggerPresent');
    Interceptor.attach(CheckRemoteDebuggerPresent, {
      onEnter(args) {
        this.debuggerPresent = args[1]; //nativepointer to pbDebuggerPresent
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] CheckRemoteDebuggerPresent");
        this.debuggerPresent.writeInt(0); //change to FALSE
      }
    });

    const GetComputerNameA = Module.getExportByName('Kernel32.dll', 'GetComputerNameA');
    Interceptor.attach(GetComputerNameA, {
      onEnter(args) {
        this.computerName = args[0]; //LPSTR lpBuffer
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] GetComputerName - replaced computer name: " + this.computerName.readCString());
      }
    });

    const GetComputerNameW = Module.getExportByName('Kernel32.dll', 'GetComputerNameW');
    Interceptor.attach(GetComputerNameW, {
      onEnter(args) {
        this.computerName = args[0]; //LPwSTR lpBuffer
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] GetComputerName - replaced computer name: " + this.computerName.readUtf16String());
      }
    });

    const GetUserNameA = Module.getExportByName('Advapi32.dll', 'GetUserNameA');
    Interceptor.attach(GetUserNameA, {
      onEnter(args) {
        this.userName = args[0]; //LPSTR lpBuffer
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] GetUserName - replaced username: " + this.userName.readCString());
      }
    });

    const GetUserNameW = Module.getExportByName('Advapi32.dll', 'GetUserNameW');
    Interceptor.attach(GetUserNameW, {
      onEnter(args) {
        this.userName = args[0]; //LPWSTR lpBuffer
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] GetUserName - replaced username: " + this.userName.readUtf16String());
      }
    });

    const IsNativeVhdBoot = Module.getExportByName('Kernel32.dll', 'IsNativeVhdBoot');
    Interceptor.attach(IsNativeVhdBoot, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        retval.replace(ptr(0)); //return FALSE
        send("[System Environment] IsNativeVhdBoot");
      }
    });

    const FindWindowA = Module.getExportByName('User32.dll', 'FindWindowA');
    Interceptor.attach(FindWindowA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_windowClass = args[0].readAnsiString();
        console.log('Window class checked:', checked_windowClass);
        let checked_windowName = args[1].readAnsiString();
        console.log('Window name checked:', checked_windowName);
        let to_check1 = checked_windowClass !== null ? checked_windowClass.toLowerCase() : '0123456789';
        let to_check2 = checked_windowName !== null ? checked_windowName.toLowerCase() : '0123456789';
        for (let w of windows_blacklist) {
            if (to_check1.includes(w))
            {
                send("[System Environment] FindWindow - window checked: " + checked_windowClass);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf8String('meow');
                this.dummyWindow = dummyWindow;
                args[0] = dummyWindow;
            }    
            if (to_check2.includes(w))
            {
                send("[System Environment] FindWindow - window checked: " + checked_windowName);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf8String('meow');
                this.dummyWindow = dummyWindow;
                args[1] = dummyWindow;
            }        
        }
      }
    });

    const FindWindowExA = Module.getExportByName('User32.dll', 'FindWindowExA');
    Interceptor.attach(FindWindowExA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_windowClass = args[2].readAnsiString();
        console.log('Window class checked:', checked_windowClass);
        let checked_windowName = args[3].readAnsiString();
        console.log('Window name checked:', checked_windowName);
        let to_check1 = checked_windowClass !== null ? checked_windowClass.toLowerCase() : '0123456789';
        let to_check2 = checked_windowName !== null ? checked_windowName.toLowerCase() : '0123456789';
        for (let w of windows_blacklist) {
            if (to_check1.includes(w))
            {
                send("[System Environment] FindWindow - window checked: " + checked_windowClass);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf8String('meow');
                this.dummyWindow = dummyWindow;
                args[2] = dummyWindow;
            }    
            if (to_check2.includes(w))
            {
                send("[System Environment] FindWindow - window checked: " + checked_windowName);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf8String('meow');
                this.dummyWindow = dummyWindow;
                args[3] = dummyWindow;
            }        
        }
      }
    });

    const FindWindowW = Module.getExportByName('User32.dll', 'FindWindowW');
    Interceptor.attach(FindWindowW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_windowClass = args[0].readUtf16String();
        console.log('Window class checked:', checked_windowClass);
        let checked_windowName = args[1].readUtf16String();
        console.log('Window name checked:', checked_windowName);
        let to_check1 = checked_windowClass !== null ? checked_windowClass.toLowerCase() : '0123456789';
        let to_check2 = checked_windowName !== null ? checked_windowName.toLowerCase() : '0123456789';
        for (let w of windows_blacklist) {
            if (to_check1.includes(w))
            {
                send("[System Environment] FindWindow - window checked: " + checked_windowClass);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf16String('meow');
                this.dummyWindow = dummyWindow;
                args[0] = dummyWindow;
            }    
            if (to_check2.includes(w))
            {
                send("[System Environment] FindWindow - window checked: " + checked_windowName);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf16String('meow');
                this.dummyWindow = dummyWindow;
                args[1] = dummyWindow;
            }        
        }
      }
    });

    const FindWindowExW = Module.getExportByName('User32.dll', 'FindWindowExW');
    Interceptor.attach(FindWindowExW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        let checked_windowClass = args[2].readUtf16String();
        console.log('Window class checked:', checked_windowClass);
        let checked_windowName = args[3].readUtf16String();
        console.log('Window name checked:', checked_windowName);
        let to_check1 = checked_windowClass !== null ? checked_windowClass.toLowerCase() : '0123456789';
        let to_check2 = checked_windowName !== null ? checked_windowName.toLowerCase() : '0123456789';
        for (let w of windows_blacklist) {
            if (to_check1.includes(w))
            {
                send("[System Environment] FindWindow - window checked: " + checked_windowClass);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf16String('meow');
                this.dummyWindow = dummyWindow;
                args[2] = dummyWindow;
            }    
            if (to_check2.includes(w))
            {
                send("[System Environment] FindWindow - window checked: " + checked_windowName);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf16String('meow');
                this.dummyWindow = dummyWindow;
                args[3] = dummyWindow;
            }        
        }
      }
    });

    const IsProcessorFeaturePresent = Module.getExportByName("Kernel32.dll", 'IsProcessorFeaturePresent');
    Interceptor.attach(IsProcessorFeaturePresent, {
      onEnter(args) {
        this.checkedFeature = args[0].toUInt32(); //DWORD ProcessorFeature
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (this.checkedFeature === 23) //PE_FASTFAIL_AVAILABLE
        {
            retval.replace(ptr(1)); //return TRUE - fake supported feature
            send(`[System Environment] IsProcessorFeaturePresent`);
        }   
      }
    });

    /* typedef struct _SYSTEM_INFO {
        union {
          DWORD dwOemId;
          struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
          } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
        DWORD     dwPageSize;
        LPVOID    lpMinimumApplicationAddress;
        LPVOID    lpMaximumApplicationAddress;
        DWORD_PTR dwActiveProcessorMask;
        DWORD     dwNumberOfProcessors;
        DWORD     dwProcessorType;
        DWORD     dwAllocationGranularity;
        WORD      wProcessorLevel;
        WORD      wProcessorRevision;
      } SYSTEM_INFO, *LPSYSTEM_INFO; */
    const GetSystemInfo = Module.getExportByName('Kernel32.dll', 'GetSystemInfo');
    Interceptor.attach(GetSystemInfo, {
      onEnter(args) {
          this.numProcessors = args[0].add(20); //DWORD dwNumberOfProcessors
      },
  
      onLeave() {
          if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
          send("[System Environment] GetSystemInfo - original processors count: " + this.numProcessors.readUInt());
          this.numProcessors.writeUInt(8);
          //console.log(this.numProcessors.readUInt());
      }
    });

    const GetVersionExA = Module.getExportByName('Kernel32.dll', 'GetVersionExA');
    Interceptor.attach(GetVersionExA, {
      onEnter(args) {
        this.versionMajorNumber = args[0].add(4); //DWORD dwMajorVersion
      },   
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.versionMajorNumber.writeUInt(4); //Windows 10
        send("[System Environment] GetVersion");
        //console.log(this.versionMajorNumber.readInt());
      }
    });

    const GetVersionExW = Module.getExportByName('Kernel32.dll', 'GetVersionExW');
    Interceptor.attach(GetVersionExW, {
      onEnter(args) {
        this.versionMajorNumber = args[0].add(4); //DWORD dwMajorVersion
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.versionMajorNumber.writeUInt(10); //Windows 10
        send("[System Environment] GetVersion");
        //console.log(this.versionMajorNumber.readInt());
      }
    });

    const GlobalMemoryStatus = Module.getExportByName('Kernel32.dll', 'GlobalMemoryStatus');
    Interceptor.attach(GlobalMemoryStatus, {
      onEnter(args) {
        this.physicalMemory = args[0].add(8); //SIZE_T dwTotalPhys (ulong)
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.physicalMemory.writeULong(4294967295); //fake memory size
        send("[System Environment] GlobalMemoryStatus");
        //console.log(this.physicalMemory.readULong());
      }
    });

    const GlobalMemoryStatusEx = Module.getExportByName('Kernel32.dll', 'GlobalMemoryStatusEx');
    Interceptor.attach(GlobalMemoryStatusEx, {
      onEnter(args) {
        this.physicalMemory = args[0].add(8); //DWORDLONG ullTotalPhys (ulong)
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.physicalMemory.writeULong(4294967295); //fake memory size
        send("[System Environment] GlobalMemoryStatus");
        //console.log(this.physicalMemory.readULong());
      }
    });

    const DeviceIoControl = Module.getExportByName('Kernel32.dll', 'DeviceIoControl');
    Interceptor.attach(DeviceIoControl, {
      onEnter(args) {
        this.controlCode = args[1].toUInt32(); //DWORD dwIoControlCode
        /* typedef struct _GET_LENGTH_INFORMATION {
          LARGE_INTEGER Length;
        } GET_LENGTH_INFORMATION, *PGET_LENGTH_INFORMATION; */
        this.diskSpace = args[4]; //LPVOID lpOutBuffer
      },  
      /* 
          Overwrite QuadPart with fake disk free space
          typedef union _LARGE_INTEGER {
          struct {
            DWORD LowPart;
            LONG  HighPart;
          } DUMMYSTRUCTNAME;
          struct {
            DWORD LowPart;
            LONG  HighPart;
          } u;
          LONGLONG QuadPart;
        } LARGE_INTEGER; */
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (this.controlCode === 475228) //IOCTL_DISK_GET_LENGTH_INFO constant
        {
          this.diskSpace.writeLong(4294967295); //fake disk space
          send("[System Environment] DeviceIoControl(DISK_INFO)");
          console.log(this.diskSpace.readLong());
        }
      }
    });

    const GetSystemMetrics = Module.getExportByName('User32.dll', 'GetSystemMetrics');
    Interceptor.attach(GetSystemMetrics, {
      onEnter(args) {
        this.index = args[0].toInt32(); //int nIndex (SM_CXSCREEN=0, SM_CYSCREEN=1, SM_CLEANBOOT=67)
      },  
      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (this.index === 0)
        {
          retval.replace(ptr(1280)); //fake x resolution
          send("[System Environment] GetSystemMetrics");
        }
        if (this.index === 1)
        {
          retval.replace(ptr(720)); //fake y resolution
          send("[System Environment] GetSystemMetrics");
        }
        if (this.index === 67)
        {
          retval.replace(ptr(1)); //fake normal/clean boot
          send("[System Environment] GetSystemMetrics");
        }
      }
    });

    const GetDesktopWindow = Module.getExportByName('User32.dll', 'GetDesktopWindow');
    Interceptor.attach(GetDesktopWindow, {
      onEnter() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        console.log("[System Environment] GetDesktopWindow");
      }
    });

    //likely false positive on Enigma
    const GetWindowRect = Module.getExportByName('User32.dll', 'GetWindowRect');
    Interceptor.attach(GetWindowRect, {
      onEnter(args) {
        this.right = args[1].add(8); //LONG right
        this.bottom = args[1].add(12); //LONG bottom
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] GetDesktopWindowRect");
        this.right.writeInt(1280); //fake x resolution
        this.bottom.writeInt(720); //fake y resolution
        //console.log(this.right.readInt());
        //console.log(this.bottom.readInt());
      }
    });

    const GetMonitorInfoA = Module.getExportByName('User32.dll', 'GetMonitorInfoA');
    Interceptor.attach(GetMonitorInfoA, {
      onEnter(args) {
        this.monitorInfo = args[1];
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] GetMonitorInfo");
        //fake top and bottom coordinates
        this.monitorInfo.readPointer().add(8).writeInt(2000);
        this.monitorInfo.readPointer().add(16).writeInt(1760);
      }
    });

    const GetMonitorInfoW = Module.getExportByName('User32.dll', 'GetMonitorInfoW');
    Interceptor.attach(GetMonitorInfoW, {
      onEnter(args) {
        this.monitorInfo = args[1];
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] GetMonitorInfo");
        //fake top and bottom coordinates
        this.monitorInfo.readPointer().add(8).writeInt(2000);
        this.monitorInfo.readPointer().add(16).writeInt(1760);
      }
    });

    //DEVMODEA contains variable size members?
    /* const EnumDisplaySettingsA = Module.getExportByName('User32.dll', 'EnumDisplaySettingsA');
    Interceptor.attach(EnumDisplaySettingsA, {
        onEnter(args) {
          this.devmodeWidth = args[2].readPointer().add(48); //DWORD dmPelsWidth
          this.devmodeHeight = args[2].readPointer().add(52); //DWORD dmPelsWidth
           //DEVMODEA *lpDevMode
          send("[System Environment] EnumDisplaySettingsA");
        },

        onLeave() {
          console.log("original x res: " + this.devmodeWidth.toInt32()); //DWORD dmPelsWidth
          console.log("original y res: " + this.devmodeHeight.toInt32()); //DWORD dmPelsHeight
          this.devmodeWidth.writeInt(1280); //fake x resolution
          this.devmodeHeight.writeInt(720); //fake y resolution
        }
    }); */

    const GetProcessAffinityMask = Module.getExportByName('Kernel32.dll', 'GetProcessAffinityMask');
    Interceptor.attach(GetProcessAffinityMask, {
      onEnter(args) {
        this.systemAffinityMask = args[2]; //PDWORD_PTR lpSystemAffinityMask
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] GetProcessAffinityMask");
        this.systemAffinityMask.writePointer(ptr("0x11111111")); //fake 8 cores
      }
    });

    const EnumDisplayMonitors = Module.getExportByName("User32.dll", 'EnumDisplayMonitors');
    Interceptor.attach(EnumDisplayMonitors, {
      onEnter() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] EnumDisplayMonitors");
      }
    });

    const EnumWindows = Module.getExportByName('User32.dll', 'EnumWindows');
    Interceptor.attach(EnumWindows, {
      onEnter() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] EnumWindows");
      }
    });

    let processes_blacklist = [
        "vbox",
        "vmware",
        "vgauthservice",
        "vmacthlp",
        "vmtoolsd",
        "ollydbg",					 // OllyDebug debugger
        "processhacker",			 // Process Hacker
        "tcpview",					 // Part of Sysinternals Suite
        "autoruns",					 // Part of Sysinternals Suite
        //"autorunsc",				 // Part of Sysinternals Suite
        "filemon",					 // Part of Sysinternals Suite
        "procmon",					 // Part of Sysinternals Suite
        "regmon",					 // Part of Sysinternals Suite
        "procexp",					 // Part of Sysinternals Suite
        "ida",						 // IDA Pro Interactive Disassembler
        //"idaq64",					 // IDA Pro Interactive Disassembler
        "immunitydebugger",			 // ImmunityDebugger
        "wireshark",				 // Wireshark packet sniffer
        "dumpcap",					 // Network traffic dump tool
        "hookexplorer",				 // Find various types of runtime hooks
        "importrec",				 // Import Reconstructor
        "petools",					 // PE Tool
        "lordpe",					 // LordPE
        "sysinspector",				 // ESET SysInspector
        "proc_analyzer",			 // Part of SysAnalyzer iDefense
        "sysanalyzer",				 // Part of SysAnalyzer iDefense
        "sniff_hit",				 // Part of SysAnalyzer iDefense
        "windbg",					 // Microsoft WinDbg
        "joebox",                    // Joe Sandbox
        "resourcehacker",			 // Resource Hacker
        "x32dbg",					 // x32dbg
        "x64dbg",					 // x64dbg
        "fiddler",					 // Fiddler
        "httpdebugger",				 // Http Debugger
        "netmon",					 // Part of Sysinternals Suite
        "ghidra",
        "tcpdump",
        "netstat",					 
        "cain",						 
        "httpanalyzerstdv7",
        "cheatengine",
        "apimonitor",
        "scylla",	 
        //"frida-helper-32",
        //"frida-helper-64",
        "frida"
    ];

    //many false positives, called also by normal processes, fixed as in stalling
    const NtQuerySystemInformation = Module.getExportByName('ntdll.dll', 'NtQuerySystemInformation');
    Interceptor.attach(NtQuerySystemInformation, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.sysInfoClass = args[0];
        this.sysInfo = args[1];
        this.spi = false;
        this.kdi = false;
        this.pmi = false;
        this.fti = false;

        if (this.sysInfoClass.toInt32() === 5) //0x05 SystemProcessInformation
            this.spi = true;
        if (this.sysInfoClass.toInt32() === 35) //0x23 SystemKernelDebuggerInformation
            this.kdi = true;
        if (this.sysInfoClass.toInt32() === 184) //0xB8 SystemPhysicalMemoryInformation
            this.pmi = true;
        if (this.sysInfoClass.toInt32() === 76) //0x4C SystemFirmwareTableInformation
            this.fti = true;
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (this.spi)
        {
            let NextEntryOffset = this.sysInfo.readU32();
            //while there are still processes in the list (this should be fixed because it skips the first process)
            while (NextEntryOffset != 0) //ULONG NextEntryOffset
            {
                //console.log(NextEntryOffset);
                //0x38 offset to UNICODE_STRING ImageName + 0x4 to get ImageName->Buffer (total 60)
                let processName = this.sysInfo.add(NextEntryOffset).add(60).readPointer().readUtf16String();
                //console.log(processName);
                for (let p of processes_blacklist)
                {
                    if (processName.includes(p))
                    {
                        send(`[Processes] NtQuerySystemInformation(0x5) - replaced process: ${processName}`);
                        this.sysInfo.add(NextEntryOffset).add(60).readPointer().writeUtf16String('explorer.exe');
                    }
                }
                    
                let newOffset = this.sysInfo.add(NextEntryOffset).readU32();
                if (newOffset != 0)
                    NextEntryOffset = NextEntryOffset + newOffset;
                else
                    NextEntryOffset = 0;
            }
        }
        
        if (this.kdi)
        {
            this.sysInfo.writeByteArray([0x0]); //set KernelDebuggerEnabled to 0
            this.sysInfo.add(1).writeByteArray([0x1]); //set KernelDebuggerNotPresent to 1
            send("[System Environment] NtQuerySystemInformation(0x23)");
        }

        //SystemPhysicalMemoryInformation is undocumented, we just log the call without bypassing it
        if (this.pmi)
            send("[System Environment] NtQuerySystemInformation(0xB8) - memory info");
        //SystemFirmwareTableInformation is undocumented, we just log the call without bypassing it
        if (this.fti)
            send("[System Environment] NtQuerySystemInformation(0x4C) - firmware tables");
      }
    });

    let totalDebugObjects = 0;

    const NtCreateDebugObject = Module.getExportByName('ntdll.dll', 'NtCreateDebugObject');
    Interceptor.attach(NtCreateDebugObject, {
      onEnter() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] NtCreateDebugObject");
        totalDebugObjects++;
      }
    });

    const NtQueryObject = Module.getExportByName('ntdll.dll', 'NtQueryObject');
    Interceptor.attach(NtQueryObject, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        this.totalObjects = args[2].add(8); //ULONG TotalNumberOfObjects (offset 0x8 on x86, 0x10 on x64)
        if (totalDebugObjects > 0)
        {
            this.totalObjects.writeU32(1); //max 1 debug object
            send("[System Environment] NtQueryObject_after_NtCreateDebugObject");
        }   
      }
    });
    
    const GetDiskSpaceInformationA = Module.getExportByName('Kernel32.dll', 'GetDiskSpaceInformationA');
    Interceptor.attach(GetDiskSpaceInformationA, {
      onEnter(args) {
        //DISK_SPACE_INFORMATION *diskSpaceInfo
        this.availableAllocUnits = args[0].add(8).readULong(); //ULONGLONG ActualAvailableAllocationUnits
        this.sectorsPerUnit = args[0].add(88).readUInt(); //DWORD SectorsPerAllocationUnit
        this.bytesPerSector = args[0].add(92).readUInt(); //DWORD BytesPerSector
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toInt32() !== 0)
        {
          this.availableAllocUnits.writeULong(this.availableAllocUnits.readULong() * 5);
          send("[System Environment] GetDiskSpaceInformation");
        }
      }
    });

    const GetDiskSpaceInformationW = Module.getExportByName('Kernel32.dll', 'GetDiskSpaceInformationW');
    Interceptor.attach(GetDiskSpaceInformationW, {
      onEnter(args) {
        //DISK_SPACE_INFORMATION *diskSpaceInfo
        this.availableAllocUnits = args[0].add(8).readULong(); //ULONGLONG ActualAvailableAllocationUnits
        this.sectorsPerUnit = args[0].add(88).readUInt(); //DWORD SectorsPerAllocationUnit
        this.bytesPerSector = args[0].add(92).readUInt(); //DWORD BytesPerSector
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toInt32() !== 0)
        {
          this.availableAllocUnits.writeULong(this.availableAllocUnits.readULong() * 5);
          send("[System Environment] GetDiskSpaceInformation");
        }
      }
    });

    const GetDiskFreeSpaceA = Module.getExportByName('Kernel32.dll', 'GetDiskFreeSpaceA');
    Interceptor.attach(GetDiskFreeSpaceA, {
      onEnter(args) {
        this.freeClusters = args[3]; //LPDWORD lpNumberOfFreeClusters
        this.totalClusters = args[4]; //LPDWORD lpTotalNumberOfClusters
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toInt32() !== 0)
        {
          this.freeClusters.writeUInt(this.freeClusters.readUInt() * 5);
          this.totalClusters.writeUInt(this.totalClusters.readUInt() * 5);
          send("[System Environment] GetDiskFreeSpace");
        }
      }
    });

    const GetDiskFreeSpaceW = Module.getExportByName('Kernel32.dll', 'GetDiskFreeSpaceW');
    Interceptor.attach(GetDiskFreeSpaceW, {
      onEnter(args) {
        this.freeClusters = args[3]; //LPDWORD lpNumberOfFreeClusters
        this.totalClusters = args[4]; //LPDWORD lpTotalNumberOfClusters
      },  

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (retval.toInt32() !== 0)
        {
          this.freeClusters.writeUInt(this.freeClusters.readUInt() * 5);
          this.totalClusters.writeUInt(this.totalClusters.readUInt() * 5);
          send("[System Environment] GetDiskFreeSpace");
        }
      }
    });

    const GetDiskFreeSpaceExA = Module.getExportByName('Kernel32.dll', 'GetDiskFreeSpaceExA');
    Interceptor.attach(GetDiskFreeSpaceExA, {
      onEnter(args) {
        this.freeBytesCaller = args[1]; //PULARGE_INTEGER lpFreeBytesAvailableToCaller
        this.totalBytes = args[2]; //PULARGE_INTEGER lpTotalNumberOfBytes
        this.totalFreeBytes = args[3]; //PULARGE_INTEGER lpTotalNumberOfFreeBytes
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (this.freeBytesCaller !== NULL)
          this.freeBytesCaller.writeULong(this.freeBytesCaller.readULong() * 5);
        if (this.totalBytes !== NULL)
          this.totalBytes.writeULong(this.totalBytes.readULong() * 5);
        if (this.totalFreeBytes !== NULL)
          this.totalFreeBytes.writeULong(this.totalFreeBytes.readULong() * 5);  
        send("[System Environment] GetDiskFreeSpace");
      }
    });

    const GetDiskFreeSpaceExW = Module.getExportByName('Kernel32.dll', 'GetDiskFreeSpaceExW');
    Interceptor.attach(GetDiskFreeSpaceExW, {
      onEnter(args) {
        this.freeBytesCaller = args[1]; //PULARGE_INTEGER lpFreeBytesAvailableToCaller
        this.totalBytes = args[2]; //PULARGE_INTEGER lpTotalNumberOfBytes
        this.totalFreeBytes = args[3]; //PULARGE_INTEGER lpTotalNumberOfFreeBytes
      },  
      
      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (this.freeBytesCaller !== NULL)
          this.freeBytesCaller.writeULong(this.freeBytesCaller.readULong() * 5);
        if (this.totalBytes !== NULL)
          this.totalBytes.writeULong(this.totalBytes.readULong() * 5);
        if (this.totalFreeBytes !== NULL)
          this.totalFreeBytes.writeULong(this.totalFreeBytes.readULong() * 5);  
        send("[System Environment] GetDiskFreeSpace");
      }
    });

    const GetAdaptersAddresses = Module.getExportByName('Iphlpapi.dll', 'GetAdaptersAddresses');
    Interceptor.attach(GetAdaptersAddresses, {
      onEnter(args) {
        this.adapterAddresses = args[3]; //PIP_ADAPTER_ADDRESSES AdapterAddresses
      },  

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        //should add check for return value
        if (this.adapterAddresses !== NULL)
        {
          //offset 44=0x2c from the beginning of the struct
          //overwrite with fake MAC address
          send("[System Environment] GetAdaptersAddresses - replaced MAC address" + this.adapterAddresses.readPointer().add(44).readByteArray(6));
          this.adapterAddresses.readPointer().add(44).writeByteArray([ 0xcc, 0x2f, 0x71, 0x23, 0x34, 0x56 ]); //BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH]
        }
      }
    });

    const GetAdaptersInfo = Module.getExportByName('Iphlpapi.dll', 'GetAdaptersInfo');
    Interceptor.attach(GetAdaptersInfo, {
      onEnter(args) {
        this.adapterInfo = args[0]; //PIP_ADAPTER_INFO AdapterInfo
      },  

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        //should add check for return value
        if (this.adapterInfo !== NULL)
        {
          //overwrite with fake name and MAC address
          //offset 8=0x8 from the beginning of the struct -> char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4] (ANSI string)
          //offset 8 + 256 + 128 + 4=396 -> BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
          //source: https://www.rpi.edu/dept/cis/software/g77-mingw32/include/iptypes.h
          send("[System Environment] GetAdaptersInfo - replaced name and MAC address"); //+ this.adapterInfo.readPointer().add(8).readAnsiString());
          //this.adapterInfo.readPointer().add(8).writeAnsiString('ASUS XG-C100C'); //fake adapter name - access violation
          //this.adapterInfo.readPointer().add(396).writeByteArray([ 0xcc, 0x2f, 0x71, 0x23, 0x34, 0x56 ]); //fake MAC address
        }
      }
    });

    //https://github.com/LordNoteworthy/al-khaser/blob/master/al-khaser/AntiDebug/NtSystemDebugControl.cpp
    const NtSystemDebugControl = Module.getExportByName('ntdll.dll', 'NtSystemDebugControl');
    Interceptor.attach(NtSystemDebugControl, {
      onEnter(args) {
        this.sysDbgCommand = args[0].toInt32(); //SYSDBG_COMMAND Command
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (this.sysDbgCommand === 20) //SysDbgCheckLowMemory
        {
            send("[System Environment] NtSystemDebugControl(SysDbgCheckLowMemory)");
            retval.replace(ptr(0xC0000354)); //fake STATUS_DEBUGGER_INACTIVE
        }
      },
    });

    const GetSystemFirmwareTable = Module.getExportByName('Kernel32.dll', 'GetSystemFirmwareTable');
    Interceptor.attach(GetSystemFirmwareTable, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        send("[System Environment] GetSystemFirmwareTable");
      },
    });

    let mutex_blacklist = [
                            "sandboxie",
                            "sbie_boxed",
                            "frz_state", //deep freeze
                            "virtualpc"
                          ]

    const CreateMutexA = Module.getExportByName('Kernel32.dll', 'CreateMutexA');
    Interceptor.attach(CreateMutexA, {
      onEnter(args) {
        this.mutexName = args[2]; //LPCSTR lpName
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode ||
            this.mutexName.isNull())
            return;
        for (let m of mutex_blacklist)
        {
          if (this.mutexName.readAnsiString().toLowerCase().includes(m))
          {
              send("[System Environment] CreateMutex - " + this.mutexName.readAnsiString());
              this.mutexName.writeAnsiString("meow");
          }
        }
      },
    });

    const CreateMutexW = Module.getExportByName('Kernel32.dll', 'CreateMutexW');
    Interceptor.attach(CreateMutexW, {
      onEnter(args) {
        this.mutexName = args[2]; //LPCWSTR lpName
      },

      onLeave() {
        if (!appModules.has(this.returnAddress) && onlyAppCode ||
            this.mutexName.isNull())
            return;
        for (let m of mutex_blacklist)
        {
          if (this.mutexName.readUtf16String().toLowerCase().includes(m))
          {
              send("[System Environment] CreateMutex - " + this.mutexName.readUtf16String());
              this.mutexName.writeUtf16String("meow");
          }
        }
      },
    });

    const CreateMutexExA = Module.getExportByName('Kernel32.dll', 'CreateMutexExA');
    Interceptor.attach(CreateMutexExA, {
      onEnter(args) {
        this.mutexName = args[1]; //LPCSTR lpName
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode ||
            this.mutexName.isNull())
            return;
        for (let m of mutex_blacklist)
        {
          if (this.mutexName.readAnsiString().toLowerCase().includes(m))
          {
              send("[System Environment] CreateMutex - " + this.mutexName.readAnsiString());
              this.mutexName.writeAnsiString("meow");
          }
        }
      },
    });

    const CreateMutexExW = Module.getExportByName('Kernel32.dll', 'CreateMutexExW');
    Interceptor.attach(CreateMutexExW, {
      onEnter(args) {
        this.mutexName = args[1]; //LPCWSTR lpName
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode ||
            this.mutexName.isNull())
            return;
        for (let m of mutex_blacklist)
        {
          if (this.mutexName.readUtf16String().toLowerCase().includes(m))
          {
              send("[System Environment] CreateMutex - " + this.mutexName.readUtf16String());
              this.mutexName.writeUtf16String("meow");
          }
        }
      },
    });

    const OpenMutexW = Module.getExportByName('Kernel32.dll', 'OpenMutexW');
    Interceptor.attach(OpenMutexW, {
      onEnter(args) {
        this.mutexName = args[2]; //LPCWSTR lpName
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode ||
            this.mutexName.isNull())
            return;
        for (let m of mutex_blacklist)
        {
          if (this.mutexName.readUtf16String().toLowerCase().includes(m))
          {
              send("[System Environment] OpenMutex - " + this.mutexName.readUtf16String());
              this.mutexName.writeUtf16String("meow");
          }
        }
      },
    });

    try {
      const SetupDiGetDeviceRegistryPropertyA = Module.getExportByName(null, 'SetupDiGetDeviceRegistryPropertyA');
      Interceptor.attach(SetupDiGetDeviceRegistryPropertyA, {
          onEnter(args) {
            //this.buffer = args[4]; //PBYTE PropertyBuffer
            //this.bufferSize = args[5]; //DWORD PropertyBufferSize
          },
  
          onLeave() {
            if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
            send("[System Environment] SetupDiGetDeviceRegistryProperty");
          }
      });

      const SetupDiGetDeviceRegistryPropertyW = Module.getExportByName(null, 'SetupDiGetDeviceRegistryPropertyW');
      Interceptor.attach(SetupDiGetDeviceRegistryPropertyW, {
          onEnter(args) {
            //this.buffer = args[4]; //PBYTE PropertyBuffer
            //this.bufferSize = args[5]; //DWORD PropertyBufferSize
          },
  
          onLeave() {
            if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
            send("[System Environment] SetupDiGetDeviceRegistryProperty");
          }
      });
    } catch (error) {
        console.log(error);
    }

    try {
      const EnumPrinters = Module.getExportByName(null, 'EnumPrinters');
      Interceptor.attach(EnumPrinters, {
      onEnter() {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
          return;
        send("[System Environment] EnumPrinters");
      }
    });
    } catch (error) {
        console.log(error);
    }

    try {
      const WudfIsAnyDebuggerPresent = Module.getExportByName('WUDFPlatform.dll', 'WudfIsAnyDebuggerPresent');
      Interceptor.attach(WudfIsAnyDebuggerPresent, {
        onLeave(retval) {
          if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
          retval.replace(ptr(0)); //return FALSE
          send("[System Environment] WudfIsAnyDebuggerPresent");
        }
      });
  
      const WudfIsUserDebuggerPresent = Module.getExportByName('WUDFPlatform.dll', 'WudfIsUserDebuggerPresent');
      Interceptor.attach(WudfIsUserDebuggerPresent, {
        onLeave(retval) {
          if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
          retval.replace(ptr(0)); //return FALSE
          send("[System Environment] WudfIsUserDebuggerPresent");
        }
      });
  
      const WudfIsKernelDebuggerPresent = Module.getExportByName('WUDFPlatform.dll', 'WudfIsKernelDebuggerPresent');
      Interceptor.attach(WudfIsKernelDebuggerPresent, {
        onLeave(retval) {
          if (!appModules.has(this.returnAddress) && onlyAppCode)
              return;
          retval.replace(ptr(0)); //return FALSE
          send("[System Environment] WudfIsKernelDebuggerPresent");
        }
      });
    } catch (error) {
        console.log(error);
    }

    //should change only if serial number is “0CD1A40” or “70144646”
    const GetVolumeInformationA = Module.getExportByName('Kernel32.dll', 'GetVolumeInformationA');
    Interceptor.attach(GetVolumeInformationA, {
      onEnter(args) {
        this.volumeSerialNumber = args[3]; //LPDWORD lpVolumeSerialNumber
      },  

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (this.volumeSerialNumber !== NULL && retval.toInt32() !== 0)
        {
          send("[System Environment] GetVolumeInformationA - replaced serial number" + this.volumeSerialNumber.readUInt());
          this.volumeSerialNumber.writeU32(0xDEADB33F);
        }
      }
    });

    const GetVolumeInformationW = Module.getExportByName('Kernel32.dll', 'GetVolumeInformationW');
    Interceptor.attach(GetVolumeInformationW, {
      onEnter(args) {
        this.volumeSerialNumber = args[3]; //LPDWORD lpVolumeSerialNumber
      },  

      onLeave(retval) {
        if (!appModules.has(this.returnAddress) && onlyAppCode)
            return;
        if (this.volumeSerialNumber !== NULL && retval.toInt32() !== 0)
        {
          send("[System Environment] GetVolumeInformationW - replaced serial number" + this.volumeSerialNumber.readUInt());
          this.volumeSerialNumber.writeU32(0xDEADB33F);
        }
      }
    });

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
  