/*
 * Auto-generated by Frida. Please modify to match the signature of printf.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
    /**
     * Called synchronously when about to call printf.
     *
     * @this {object} - Object allowing you to store state for use in onLeave.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {array} args - Function arguments represented as an array of NativePointer objects.
     * For example use args[0].readCString() if the first argument is a pointer to a C string encoded as UTF-8.
     * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
     * @param {object} state - Object allowing you to keep state across function calls.
     * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
     * However, do not use this to store function arguments across onEnter/onLeave, but instead
     * use "this" which is an object for keeping state local to an invocation.
     */

    const programPath = Process.enumerateModules()[0].path;
    const appModules = new ModuleMap(m => m.path.startsWith(programPath));

    let windows_blacklist = [
                         "vbox",
                         "virtualbox",
                         "virtual box",
                         "vmware",
                         "immunity", 
                         "ollydbg", 
                         "windbg", 
                         "x64dbg", 
                         "x32dbg", 
                         "ghidra", 
                         "ida",
                         "wireshark",
                         "procmon",
                         "process monitor",
                         "fiddler",
                         "apimonitor",
                         "api monitor",
                         "scylla",
                         "debug",
                        ]

    //useful reference for data types sizes: https://learn.microsoft.com/it-it/windows/win32/winprog/windows-data-types
    const IsDebuggerPresent = Module.getExportByName('Kernel32.dll', 'IsDebuggerPresent');
    Interceptor.attach(IsDebuggerPresent, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        retval.replace(ptr(0)); //return FALSE
        send("[System Environment] IsDebuggerPresent");
      }
    });

    const CheckRemoteDebuggerPresent = Module.getExportByName('Kernel32.dll', 'CheckRemoteDebuggerPresent');
    Interceptor.attach(CheckRemoteDebuggerPresent, {
      onEnter(args) {
        this.debuggerPresent = args[1]; //nativepointer to pbDebuggerPresent
      },
   
      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[System Environment] CheckRemoteDebuggerPresent");
        this.debuggerPresent.writeInt(0); //change to FALSE
      }
    });

    const GetComputerNameA = Module.getExportByName('Kernel32.dll', 'GetComputerNameA');
    Interceptor.attach(GetComputerNameA, {
      onEnter(args) {
        this.computerName = args[0]; //LPSTR lpBuffer
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[System Environment] GetComputerNameA - replaced computer name: " + this.computerName.readCString());
      }
    });

    const GetComputerNameW = Module.getExportByName('Kernel32.dll', 'GetComputerNameW');
    Interceptor.attach(GetComputerNameW, {
      onEnter(args) {
        this.computerName = args[0]; //LPwSTR lpBuffer
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[System Environment] GetComputerNameW - replaced computer name: " + this.computerName.readUtf16String());
      }
    });

    const GetUserNameA = Module.getExportByName('Advapi32.dll', 'GetUserNameA');
    Interceptor.attach(GetUserNameA, {
      onEnter(args) {
        this.userName = args[0]; //LPSTR lpBuffer
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[System Environment] GetUserNameA - replaced username: " + this.userName.readCString());
      }
    });

    const GetUserNameW = Module.getExportByName('Advapi32.dll', 'GetUserNameW');
    Interceptor.attach(GetUserNameW, {
      onEnter(args) {
        this.userName = args[0]; //LPWSTR lpBuffer
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[System Environment] GetUserNameW - replaced username: " + this.userName.readUtf16String());
      }
    });

    const IsNativeVhdBoot = Module.getExportByName('Kernel32.dll', 'IsNativeVhdBoot');
    Interceptor.attach(IsNativeVhdBoot, {
      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        retval.replace(ptr(0)); //return FALSE
        send("[System Environment] IsNativeVhdBoot");
      }
    });

    const FindWindowA = Module.getExportByName('User32.dll', 'FindWindowA');
    Interceptor.attach(FindWindowA, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let checked_windowClass = args[0].readCString();
        console.log('Window class checked:', checked_windowClass);
        let checked_windowName = args[1].readCString();
        console.log('Window name checked:', checked_windowName);
        let to_check1 = checked_windowClass !== null ? checked_windowClass.toLowerCase() : '0123456789';
        let to_check2 = checked_windowName !== null ? checked_windowName.toLowerCase() : '0123456789';
        for (let w of windows_blacklist) {
            if (to_check1.includes(w))
            {
                send("[System Environment] FindWindowA - window checked: " + checked_windowClass);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf8String('meow');
                this.dummyWindow = dummyWindow;
                args[0] = dummyWindow;
            }    
            if (to_check2.includes(w))
            {
                send("[System Environment] FindWindowA - window checked: " + checked_windowName);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf8String('meow');
                this.dummyWindow = dummyWindow;
                args[1] = dummyWindow;
            }        
        }
      }
    });

    const FindWindowW = Module.getExportByName('User32.dll', 'FindWindowW');
    Interceptor.attach(FindWindowW, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        let checked_windowClass = args[0].readUtf16String();
        console.log('Window class checked:', checked_windowClass);
        let checked_windowName = args[1].readUtf16String();
        console.log('Window name checked:', checked_windowName);
        let to_check1 = checked_windowClass !== null ? checked_windowClass.toLowerCase() : '0123456789';
        let to_check2 = checked_windowName !== null ? checked_windowName.toLowerCase() : '0123456789';
        for (let w of windows_blacklist) {
            if (to_check1.includes(w))
            {
                send("[System Environment] FindWindowW - window checked: " + checked_windowClass);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf16String('meow');
                this.dummyWindow = dummyWindow;
                args[0] = dummyWindow;
            }    
            if (to_check2.includes(w))
            {
                send("[System Environment] FindWindowW - window checked: " + checked_windowName);
                //replace the window's name if blacklisted
                const dummyWindow = Memory.allocUtf16String('meow');
                this.dummyWindow = dummyWindow;
                args[1] = dummyWindow;
            }        
        }
      }
    });

    //likely false positive
    const IsProcessorFeaturePresent = Module.getExportByName("Kernel32.dll", 'IsProcessorFeaturePresent');
    Interceptor.attach(IsProcessorFeaturePresent, {
      onEnter(args) {
        this.checkedFeature = args[0].toUInt32(); //DWORD ProcessorFeature
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (this.checkedFeature === 3 || this.checkedFeature === 6 || this.checkedFeature === 17)
        {
            retval.replace(ptr(1)); //return TRUE
            send(`[System Environment] IsProcessorFeaturePresent - feature checked: ${this.checkedFeature}`);
        }   
      }
    });

    /* typedef struct _SYSTEM_INFO {
        union {
          DWORD dwOemId;
          struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
          } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
        DWORD     dwPageSize;
        LPVOID    lpMinimumApplicationAddress;
        LPVOID    lpMaximumApplicationAddress;
        DWORD_PTR dwActiveProcessorMask;
        DWORD     dwNumberOfProcessors;
        DWORD     dwProcessorType;
        DWORD     dwAllocationGranularity;
        WORD      wProcessorLevel;
        WORD      wProcessorRevision;
      } SYSTEM_INFO, *LPSYSTEM_INFO; */
    const GetSystemInfo = Module.getExportByName('Kernel32.dll', 'GetSystemInfo');
    Interceptor.attach(GetSystemInfo, {
      onEnter(args) {
          this.numProcessors = args[0].add(20); //DWORD dwNumberOfProcessors
      },
  
      onLeave() {
          if (!appModules.has(this.returnAddress))
          return;
          send("[System Environment] GetSystemInfo - original processors count: " + this.numProcessors.readUInt());
          this.numProcessors.writeUInt(8);
          //console.log(this.numProcessors.readUInt());
      }
    });

    const GetVersionExA = Module.getExportByName('Kernel32.dll', 'GetVersionExA');
    Interceptor.attach(GetVersionExA, {
      onEnter(args) {
        this.versionMajorNumber = args[0].add(4); //DWORD dwMajorVersion
      },   
      onLeave() {
        if (!appModules.has(this.returnAddress))
          return;
        this.versionMajorNumber.writeUInt(10); //Windows 10
        send("[System Environment] GetVersionExA");
        //console.log(this.versionMajorNumber.readInt());
      }
    });

    const GetVersionExW = Module.getExportByName('Kernel32.dll', 'GetVersionExW');
    Interceptor.attach(GetVersionExW, {
      onEnter(args) {
        this.versionMajorNumber = args[0].add(4); //DWORD dwMajorVersion
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress))
          return;
        this.versionMajorNumber.writeUInt(10); //Windows 10
        send("[System Environment] GetVersionExW");
        //console.log(this.versionMajorNumber.readInt());
      }
    });

    const GlobalMemoryStatusEx = Module.getExportByName('Kernel32.dll', 'GlobalMemoryStatusEx');
    Interceptor.attach(GlobalMemoryStatusEx, {
      onEnter(args) {
        this.physicalMemory = args[0].add(8); //DWORDLONG ullTotalPhys (ulong)
      },  
      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
          return;
        if (retval.toInt32() !== 0)
        {
          this.physicalMemory.writeULong(4294967295); //fake memory size
          send("[System Environment] GlobalMemoryStatusEx");
          console.log(this.physicalMemory.readULong());
        }
      }
    });

    const DeviceIoControl = Module.getExportByName('Kernel32.dll', 'DeviceIoControl');
    Interceptor.attach(DeviceIoControl, {
      onEnter(args) {
        this.controlCode = args[1].toUInt32(); //DWORD dwIoControlCode
        /* typedef struct _GET_LENGTH_INFORMATION {
          LARGE_INTEGER Length;
        } GET_LENGTH_INFORMATION, *PGET_LENGTH_INFORMATION; */
        this.diskSpace = args[4]; //LPVOID lpOutBuffer
      },  
      /* 
          Overwrite QuadPart with fake disk free space
          typedef union _LARGE_INTEGER {
          struct {
            DWORD LowPart;
            LONG  HighPart;
          } DUMMYSTRUCTNAME;
          struct {
            DWORD LowPart;
            LONG  HighPart;
          } u;
          LONGLONG QuadPart;
        } LARGE_INTEGER; */
      onLeave() {
          if (!appModules.has(this.returnAddress))
              return;
          if (this.controlCode === 475228) //IOCTL_DISK_GET_LENGTH_INFO constant
          {
            this.diskSpace.writeLong(4294967295); //fake disk space
            send("[System Environment] DeviceIoControl(DISK_INFO)");
            console.log(this.diskSpace.readLong());
          }
      }
    });

    const GetSystemMetrics = Module.getExportByName('User32.dll', 'GetSystemMetrics');
    Interceptor.attach(GetSystemMetrics, {
      onEnter(args) {
        this.index = args[0].toInt32(); //int nIndex (SM_CXSCREEN=0, SM_CYSCREEN=1, SM_CLEANBOOT=67)
      },  
      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
          return;
        if (this.index === 0)
          retval.replace(ptr(1280)); //fake x resolution
          send("[System Environment] GetSystemMetrics(SM_CXSCREEN)");
        if (this.index === 1)
          retval.replace(ptr(720)); //fake y resolution
          send("[System Environment] GetSystemMetrics(SM_CYSCREEN)");
        if (this.index === 67)
          retval.replace(ptr(1)); //fake normal/clean boot
          send("[System Environment] GetSystemMetrics(SM_CLEANBOOT)");
      }
    });

    const GetDesktopWindow = Module.getExportByName('User32.dll', 'GetDesktopWindow');
    Interceptor.attach(GetDesktopWindow, {
      onEnter() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[System Environment] GetDesktopWindow");
      }
    });

    //likely false positive on Enigma
    const GetWindowRect = Module.getExportByName('User32.dll', 'GetWindowRect');
    Interceptor.attach(GetWindowRect, {
      onEnter(args) {
        this.right = args[1].add(8); //LONG right
        this.bottom = args[1].add(12); //LONG bottom
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress))
          return;
        send("[System Environment] GetWindowRect");
        this.right.writeInt(1280); //fake x resolution
        this.bottom.writeInt(720); //fake y resolution
        //console.log(this.right.readInt());
        //console.log(this.bottom.readInt());
      }
    });

    //DEVMODEA contains variable size members?
    /* const EnumDisplaySettingsA = Module.getExportByName('User32.dll', 'EnumDisplaySettingsA');
    Interceptor.attach(EnumDisplaySettingsA, {
        onEnter(args) {
          this.devmodeWidth = args[2].readPointer().add(48); //DWORD dmPelsWidth
          this.devmodeHeight = args[2].readPointer().add(52); //DWORD dmPelsWidth
           //DEVMODEA *lpDevMode
          send("[System Environment] EnumDisplaySettingsA");
        },

        onLeave() {
          console.log("original x res: " + this.devmodeWidth.toInt32()); //DWORD dmPelsWidth
          console.log("original y res: " + this.devmodeHeight.toInt32()); //DWORD dmPelsHeight
          this.devmodeWidth.writeInt(1280); //fake x resolution
          this.devmodeHeight.writeInt(720); //fake y resolution
        }
    }); */

    const GetProcessAffinityMask = Module.getExportByName('Kernel32.dll', 'GetProcessAffinityMask');
    Interceptor.attach(GetProcessAffinityMask, {
      onEnter(args) {
        this.systemAffinityMask = args[2]; //PDWORD_PTR lpSystemAffinityMask
      },  
      onLeave() {
        if (!appModules.has(this.returnAddress))
          return;
        send("[System Environment] GetProcessAffinityMask");
        this.systemAffinityMask.writePointer(ptr("0x11111111")); //fake 8 cores
      }
    });

    const EnumDisplayMonitors = Module.getExportByName("User32.dll", 'EnumDisplayMonitors');
    Interceptor.attach(EnumDisplayMonitors, {
      onEnter() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[System Environment] EnumDisplayMonitors");
      }
    });

    const EnumWindows = Module.getExportByName('User32.dll', 'EnumWindows');
    Interceptor.attach(EnumWindows, {
      onEnter() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[System Environment] EnumWindows");
      }
    });

    let processes_blacklist = [
        "vbox",
        "vmware",
        "vgauthservice",
        "vmacthlp",
        "vmtoolsd",
        "ollydbg",					 // OllyDebug debugger
		"processhacker",			 // Process Hacker
		"tcpview",					 // Part of Sysinternals Suite
		"autoruns",					 // Part of Sysinternals Suite
		//"autorunsc",				 // Part of Sysinternals Suite
		"filemon",					 // Part of Sysinternals Suite
		"procmon",					 // Part of Sysinternals Suite
		"regmon",					 // Part of Sysinternals Suite
		"procexp",					 // Part of Sysinternals Suite
		"ida",						 // IDA Pro Interactive Disassembler
		//"idaq64",					 // IDA Pro Interactive Disassembler
		"immunitydebugger",			 // ImmunityDebugger
		"wireshark",				 // Wireshark packet sniffer
		"dumpcap",					 // Network traffic dump tool
		"hookexplorer",				 // Find various types of runtime hooks
		"importrec",				 // Import Reconstructor
		"petools",					 // PE Tool
		"lordpe",					 // LordPE
		"sysinspector",				 // ESET SysInspector
		"proc_analyzer",			 // Part of SysAnalyzer iDefense
		"sysanalyzer",				 // Part of SysAnalyzer iDefense
		"sniff_hit",				 // Part of SysAnalyzer iDefense
		"windbg",					 // Microsoft WinDbg
		"joebox",                    // Joe Sandbox
		"resourcehacker",			 // Resource Hacker
		"x32dbg",					 // x32dbg
		"x64dbg",					 // x64dbg
		"fiddler",					 // Fiddler
		"httpdebugger",				 // Http Debugger
		"netmon",					 // Part of Sysinternals Suite
        "ghidra",
        "tcpdump",
		"netstat",					 
		"cain",						 
		"httpanalyzerstdv7",
        "cheatengine",
        "apimonitor",
        "scylla",	 
		//"frida-helper-32",
		//"frida-helper-64",
        "frida"
    ];

    //many false positives, called also by normal processes, fixed as in stalling
    const NtQuerySystemInformation = Module.getExportByName('ntdll.dll', 'NtQuerySystemInformation');
    Interceptor.attach(NtQuerySystemInformation, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.sysInfoClass = args[0];
        this.sysInfo = args[1];
        this.spi = false;
        this.kdi = false;
        this.pmi = false;

        if (this.sysInfoClass.toInt32() === 5) //0x05 SystemProcessInformation
            this.spi = true;
        if (this.sysInfoClass.toInt32() === 35) //0x23 SystemKernelDebuggerInformation
            this.kdi = true;
        if (this.sysInfoClass.toInt32() === 184) //0xB8 SystemPhysicalMemoryInformation
            this.pmi = true;
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
            return;
        if (this.spi)
        {
            let NextEntryOffset = this.sysInfo.readU32();
            //while there are still processes in the list (this should be fixed because it skips the first process)
            while (NextEntryOffset != 0) //ULONG NextEntryOffset
            {
                //console.log(NextEntryOffset);
                //0x38 offset to UNICODE_STRING ImageName + 0x4 to get ImageName->Buffer (total 60)
                let processName = this.sysInfo.add(NextEntryOffset).add(60).readPointer().readUtf16String();
                //console.log(processName);
                for (let p of processes_blacklist)
                {
                    if (processName.includes(p))
                    {
                        send(`[Processes] NtQuerySystemInformation(0x5) - process checked: ${processName}`);
                        this.sysInfo.add(NextEntryOffset).add(60).readPointer().writeUtf16String('meow');
                    }
                }
                    
                let newOffset = this.sysInfo.add(NextEntryOffset).readU32();
                if (newOffset != 0)
                    NextEntryOffset = NextEntryOffset + newOffset;
                else
                    NextEntryOffset = 0;
            }
        }
        
        if (this.kdi)
        {
            this.sysInfo.writeByteArray([0x0]); //set KernelDebuggerEnabled to 0
            this.sysInfo.add(1).writeByteArray([0x1]); //set KernelDebuggerNotPresent to 1
            send("[System Environment] NtQuerySystemInformation(0x23)");
        }

        //SystemPhysicalMemoryInformation is undocumented, we just log the call without bypassing it
        if (this.pmi)
            send("[System Environment] NtQuerySystemInformation(0xB8)");
      }
    });

    let totalDebugObjects = 0;

    const NtCreateDebugObject = Module.getExportByName('ntdll.dll', 'NtCreateDebugObject');
    Interceptor.attach(NtCreateDebugObject, {
      onEnter() {
        if (!appModules.has(this.returnAddress))
            return;
        send("[System Environment] NtCreateDebugObject");
        totalDebugObjects++;
      }
    });

    const NtQueryObject = Module.getExportByName('ntdll.dll', 'NtQueryObject');
    Interceptor.attach(NtQueryObject, {
      onEnter(args) {
        if (!appModules.has(this.returnAddress))
            return;
        this.totalObjects = args[2].add(8); //ULONG TotalNumberOfObjects (offset 0x8 on x86, 0x10 on x64)
        if (totalDebugObjects > 0)
        {
            this.totalObjects.writeU32(1); //max 1 debug object
            send("[System Environment] NtQueryObject_after_NtCreateDebugObject");
        }   
      }
    });
    
    const GetDiskFreeSpaceA = Module.getExportByName('Kernel32.dll', 'GetDiskFreeSpaceA');
    Interceptor.attach(GetDiskFreeSpaceA, {
      onEnter(args) {
        this.freeClusters = args[3]; //LPDWORD lpNumberOfFreeClusters
        this.totalClusters = args[4]; //LPDWORD lpTotalNumberOfClusters
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
          return;
        if (retval.toInt32() !== 0)
        {
          this.freeClusters.writeUInt(this.freeClusters.readUInt() * 5);
          this.totalClusters.writeUInt(this.totalClusters.readUInt() * 5);
          send("[System Environment] GetDiskFreeSpaceA");
        }
      }
    });

    const GetDiskFreeSpaceW = Module.getExportByName('Kernel32.dll', 'GetDiskFreeSpaceW');
    Interceptor.attach(GetDiskFreeSpaceW, {
      onEnter(args) {
        this.freeClusters = args[3]; //LPDWORD lpNumberOfFreeClusters
        this.totalClusters = args[4]; //LPDWORD lpTotalNumberOfClusters
      },  

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
          return;
        if (retval.toInt32() !== 0)
        {
          this.freeClusters.writeUInt(this.freeClusters.readUInt() * 5);
          this.totalClusters.writeUInt(this.totalClusters.readUInt() * 5);
          send("[System Environment] GetDiskFreeSpaceW");
        }
      }
    });

    const GetDiskFreeSpaceExA = Module.getExportByName('Kernel32.dll', 'GetDiskFreeSpaceExA');
    Interceptor.attach(GetDiskFreeSpaceExA, {
      onEnter(args) {
        this.freeBytesCaller = args[1]; //PULARGE_INTEGER lpFreeBytesAvailableToCaller
        this.totalBytes = args[2]; //PULARGE_INTEGER lpTotalNumberOfBytes
        this.totalFreeBytes = args[3]; //PULARGE_INTEGER lpTotalNumberOfFreeBytes
      },

      onLeave() {
        if (!appModules.has(this.returnAddress))
          return;
        if (this.freeBytesCaller !== NULL)
          this.freeBytesCaller.writeULong(this.freeBytesCaller.readULong() * 5);
        if (this.totalBytes !== NULL)
          this.totalBytes.writeULong(this.totalBytes.readULong() * 5);
        if (this.totalFreeBytes !== NULL)
          this.totalFreeBytes.writeULong(this.totalFreeBytes.readULong() * 5);  
        send("[System Environment] GetDiskFreeSpaceExA");
      }
    });

    const GetDiskFreeSpaceExW = Module.getExportByName('Kernel32.dll', 'GetDiskFreeSpaceExW');
    Interceptor.attach(GetDiskFreeSpaceExW, {
      onEnter(args) {
        this.freeBytesCaller = args[1]; //PULARGE_INTEGER lpFreeBytesAvailableToCaller
        this.totalBytes = args[2]; //PULARGE_INTEGER lpTotalNumberOfBytes
        this.totalFreeBytes = args[3]; //PULARGE_INTEGER lpTotalNumberOfFreeBytes
      },  
      
      onLeave() {
        if (!appModules.has(this.returnAddress))
          return;
        if (this.freeBytesCaller !== NULL)
          this.freeBytesCaller.writeULong(this.freeBytesCaller.readULong() * 5);
        if (this.totalBytes !== NULL)
          this.totalBytes.writeULong(this.totalBytes.readULong() * 5);
        if (this.totalFreeBytes !== NULL)
          this.totalFreeBytes.writeULong(this.totalFreeBytes.readULong() * 5);  
        send("[System Environment] GetDiskFreeSpaceExW");
      }
    });

    const GetAdaptersAddresses = Module.getExportByName('Iphlpapi.dll', 'GetAdaptersAddresses');
    Interceptor.attach(GetAdaptersAddresses, {
      onEnter(args) {
        this.adapterAddresses = args[3]; //PIP_ADAPTER_ADDRESSES AdapterAddresses
      },  

      onLeave() {
        if (!appModules.has(this.returnAddress))
          return;
        //should add check for return value
        if (this.adapterAddresses !== NULL)
        {
          //offset 44=0x2c from the beginning of the struct
          //overwrite with fake MAC address
          this.adapterAddresses.add(44).readPointer().writeByteArray([ 0xcc, 0x2f, 0x71, 0x23, 0x34, 0x56 ]); //BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH]
          send("[System Environment] GetAdaptersAddresses replaced MAC address");
          console.log(this.adapterAddresses.add(44).readPointer().readByteArray(6));
        }
      }
    });

    const GetAdaptersInfo = Module.getExportByName('Iphlpapi.dll', 'GetAdaptersInfo');
    Interceptor.attach(GetAdaptersInfo, {
      onEnter(args) {
        this.adapterInfo = args[0]; //PIP_ADAPTER_INFO AdapterInfo
      },  

      onLeave() {
        if (!appModules.has(this.returnAddress))
          return;
        //should add check for return value
        if (this.adapterInfo !== NULL)
        {
          //overwrite with fake name and MAC address
          //offset 8=0x8 from the beginning of the struct -> char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4] (ANSI string)
          //offset 8 + 256 + 128 + 4=396 -> BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
          //source: https://www.rpi.edu/dept/cis/software/g77-mingw32/include/iptypes.h
          this.adapterInfo.add(8).readPointer().writeAnsiString('ASUS XG-C100C'); //fake adapter name
          this.adapterInfo.add(396).readPointer().writeByteArray([ 0xcc, 0x2f, 0x71, 0x23, 0x34, 0x56 ]); //fake MAC address
          send("[System Environment] GetAdaptersInfo replaced name and MAC address");
          console.log(this.adapterInfo.add(8).readPointer().readAnsiString());
          console.log(this.adapterInfo.add(396).readPointer().readByteArray(6));
        }
      }
    });

    //https://github.com/LordNoteworthy/al-khaser/blob/master/al-khaser/AntiDebug/NtSystemDebugControl.cpp
    const NtSystemDebugControl = Module.getExportByName('ntdll.dll', 'NtSystemDebugControl');
    Interceptor.attach(NtSystemDebugControl, {
      onEnter(args) {
        this.sysDbgCommand = args[0].toInt32(); //SYSDBG_COMMAND Command
      },

      onLeave(retval) {
        if (!appModules.has(this.returnAddress))
            return;
        if (this.sysDbgCommand === 20) //SysDbgCheckLowMemory
        {
            send("[System Environment] NtSystemDebugControl(SysDbgCheckLowMemory)");
            retval.replace(ptr(0xC0000354)); //fake STATUS_DEBUGGER_INACTIVE
        }
      },
    });

    /* const SetupDiGetDeviceRegistryPropertyA = Module.getExportByName(null, 'SetupDiGetDeviceRegistryPropertyA');
    Interceptor.attach(SetupDiGetDeviceRegistryPropertyA, {
        onEnter(args) {
          this.buffer = args[4]; //PBYTE PropertyBuffer
          this.bufferSize = args[5]; //DWORD PropertyBufferSize
          send("[System Environment] SetupDiGetDeviceRegistryPropertyA");
        },

        onLeave() {
          if (this.bufferSize.toUInt32() !== 0)
            
        }
    }); */

    try {
        const EnumPrinters = Module.getExportByName(null, 'EnumPrinters');
        Interceptor.attach(EnumPrinters, {
        onEnter() {
          if (!appModules.has(this.returnAddress))
              return;
          send("[System Environment] EnumPrinters");
        }
    });
    } catch (error) {
        console.log(error);
    }

    /**
     * Called synchronously when about to return from printf.
     *
     * See onEnter for details.
     *
     * @this {object} - Object allowing you to access state stored in onEnter.
     * @param {function} log - Call this function with a string to be presented to the user.
     * @param {NativePointer} retval - Return value represented as a NativePointer object.
     * @param {object} state - Object allowing you to keep state across function calls.
     */
  }
  